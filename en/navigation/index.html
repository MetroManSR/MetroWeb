<!DOCTYPE html>
<html>
<head>
    <title>Enhanced ASCII Terrain Map</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #121212;
            color: #e0e0e0;
            text-align: center;
            margin: 0;
            padding: 20px;
        }
        #map-container {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            margin-bottom: 20px;
            display: inline-block;
            position: relative;
        }
        #map {
            font-size: 8px;
            line-height: 8px;
            letter-spacing: 1px;
            white-space: pre;
            overflow: auto;
            max-height: 700px;
            max-width: 1000px;
            padding: 10px;
            background: #222;
            border-radius: 4px;
            cursor: crosshair;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }
        button {
            background: #333;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            transition: background 0.2s;
            font-size: 14px;
        }
        button:hover {
            background: #444;
        }
        .control-group {
            background: #252525;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            justify-content: center;
        }
        input {
            background: #252525;
            color: white;
            border: 1px solid #444;
            padding: 10px;
            border-radius: 4px;
            min-width: 200px;
        }
        #coords, #location-info, #elevation-info {
            font-family: monospace;
            background: #252525;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            display: inline-block;
            font-size: 14px;
        }
        /* Terrain Colors */
        .water { color: #5af; }
        .ground { color: #ba9; }
        .building { color: #f88; }
        .road { color: #fd5; }
        .major-road { color: #fa0; }
        .park { color: #5c5; }
        .forest { color: #3a5; }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 100;
            font-size: 14px;
            white-space: nowrap;
            font-family: monospace;
        }
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            min-height: 300px;
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #fff;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .nav-btn {
            font-size: 18px;
            padding: 12px;
        }
        .zoom-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <h1>Enhanced ASCII Terrain Map</h1>
    
    <div class="control-group">
        <div class="input-group">
            <input type="text" id="addressInput" placeholder="Search address or place">
            <button id="searchAddress">Search</button>
        </div>
        
        <div class="input-group">
            <input type="text" id="latInput" placeholder="Latitude" value="40.7128">
            <input type="text" id="lonInput" placeholder="Longitude" value="-74.0060">
            <button id="goToCoords">Go</button>
        </div>
    </div>
    
    <div id="coords">Latitude: 40.7128, Longitude: -74.0060</div>
    <div id="location-info">New York, US</div>
    <div id="elevation-info">Click on the map to see details</div>
    
    <div class="zoom-controls">
        <button id="zoomIn">+ Zoom In</button>
        <button id="zoomOut">- Zoom Out</button>
    </div>
    
    <div class="controls">
        <div></div>
        <button class="nav-btn" id="moveNorth">↑</button>
        <div></div>
        <button class="nav-btn" id="moveWest">←</button>
        <button id="recenter">◎</button>
        <button class="nav-btn" id="moveEast">→</button>
        <div></div>
        <button class="nav-btn" id="moveSouth">↓</button>
        <div></div>
    </div>
    
    <div id="map-container">
        <div id="map" class="loading">
            <div class="loading-spinner"></div>
            <div>Loading terrain data...</div>
        </div>
        <div class="tooltip" id="tooltip" style="display: none;"></div>
    </div>

    <script>
        // ================ CONFIGURATION ================
        const MAP_SIZE = 100; // 100x100 grid
        const BASE_CELL_SIZE = 100; // Base 100m per cell
        let currentCellSize = BASE_CELL_SIZE;
        const BASE_MOVE_DISTANCE = 0.03; // ~3km base movement
        let currentMoveDistance = BASE_MOVE_DISTANCE;
        const ZOOM_FACTOR = 1.5;
        
        // ================ STATE MANAGEMENT ================
        let currentLat = 40.7128; // New York
        let currentLon = -74.0060;
        let isLoading = false;
        let elevationData = Array(MAP_SIZE).fill().map(() => Array(MAP_SIZE).fill(0));
        let osmFeatures = [];

        // ================ ELEVATION DATA ================
        async function fetchElevationData() {
            isLoading = true;
            document.getElementById('map').className = 'loading';
            
            try {
                // Calculate the bounds of our map area
                const metersPerDegreeLat = 111320;
                const metersPerDegreeLon = 111320 * Math.cos(currentLat * Math.PI/180);
                
                // First fetch OSM data for the area
                await fetchOSMData();
                
                // Prepare elevation points to fetch
                const locations = [];
                for (let y = 0; y < MAP_SIZE; y++) {
                    for (let x = 0; x < MAP_SIZE; x++) {
                        const lat = currentLat + (y - MAP_SIZE/2) * (currentCellSize / metersPerDegreeLat);
                        const lon = currentLon + (x - MAP_SIZE/2) * (currentCellSize / metersPerDegreeLon);
                        locations.push({ latitude: lat, longitude: lon, x, y });
                    }
                }
                
                // Fetch elevation data
                const elevations = await getElevations(locations);
                
                // Store elevations
                elevations.forEach((elev, index) => {
                    const {x, y} = locations[index];
                    elevationData[y][x] = elev;
                });
                
                // Render map
                renderMap();
                updateStatus("Map ready");
                updateLocationInfo();
            } catch (error) {
                console.error("Error loading map:", error);
                updateStatus("Error loading map");
            } finally {
                isLoading = false;
            }
        }

        async function getElevations(locations) {
            try {
                // Try Open-Elevation API first
                const response = await fetch('https://api.open-elevation.com/api/v1/lookup', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        locations: locations.map(loc => ({ 
                            latitude: loc.latitude, 
                            longitude: loc.longitude 
                        }))
                    })
                });
                
                if (!response.ok) throw new Error("Elevation API failed");
                const data = await response.json();
                return data.results.map(r => r.elevation);
            } catch (e) {
                console.error("Using Mapzen elevation service as fallback:", e);
                // Fallback to Mapzen elevation service
                const locationsStr = locations.map(loc => 
                    `${loc.latitude.toFixed(6)},${loc.longitude.toFixed(6)}`).join('|');
                
                const response = await fetch(
                    `https://elevation.racemap.com/api?locations=${locationsStr}`
                );
                
                if (!response.ok) throw new Error("Fallback elevation service failed");
                return await response.json();
            }
        }

        // ================ OSM DATA ================
        async function fetchOSMData() {
            try {
                const radius = currentMoveDistance * 1.5; // Dynamic radius based on zoom
                const bbox = `${currentLon - radius},${currentLat - radius},${currentLon + radius},${currentLat + radius}`;
                
                const query = `
                    [out:json];
                    (
                        way[building](${bbox});
                        way[highway](${bbox});
                        way[landuse=forest](${bbox});
                        way[leisure=park](${bbox});
                        way[natural=water](${bbox});
                    );
                    out geom;
                `;
                
                const response = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`);
                if (!response.ok) throw new Error("Failed to fetch OSM data");
                osmFeatures = (await response.json()).elements;
            } catch (e) {
                console.error("Error fetching OSM data:", e);
                osmFeatures = [];
            }
        }

        // ================ RENDERING ================
        function renderMap() {
            let mapOutput = '';
            const centerElev = elevationData[Math.floor(MAP_SIZE/2)][Math.floor(MAP_SIZE/2)];
            
            // Convert OSM features to grid coordinates
            const osmGrid = createOSMFeatureGrid();
            
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const elev = elevationData[y][x];
                    
                    // Check OSM features first
                    if (osmGrid[y] && osmGrid[y][x]) {
                        const feature = osmGrid[y][x];
                        if (feature.type === 'water') {
                            mapOutput += `<span class="water">≈</span>`;
                        } else if (feature.type === 'road') {
                            mapOutput += `<span class="road">─</span>`;
                        } else if (feature.type === 'major-road') {
                            mapOutput += `<span class="major-road">═</span>`;
                        } else if (feature.type === 'building') {
                            mapOutput += `<span class="building">█</span>`;
                        } else if (feature.type === 'park') {
                            mapOutput += `<span class="park">♣</span>`;
                        } else if (feature.type === 'forest') {
                            mapOutput += `<span class="forest">♠</span>`;
                        } else {
                            mapOutput += getElevationCell(elev, centerElev, x, y);
                        }
                    } else {
                        mapOutput += getElevationCell(elev, centerElev, x, y);
                    }
                }
                mapOutput += '\n';
            }
            
            document.getElementById('map').innerHTML = mapOutput;
            document.getElementById('map').className = '';
        }

        function getElevationCell(elev, centerElev, x, y) {
            const relElev = elev - centerElev;
            
            if (elev < 10) {
                return `<span class="water" data-x="${x}" data-y="${y}">≈</span>`;
            } else if (Math.abs(relElev) < 5) {
                return `<span class="ground" data-x="${x}" data-y="${y}">·</span>`;
            } else if (relElev > 20) {
                return `<span class="building" data-x="${x}" data-y="${y}">▲</span>`;
            } else if (relElev < -5) {
                return `<span class="water" data-x="${x}" data-y="${y}">≈</span>`;
            } else {
                return `<span class="ground" data-x="${x}" data-y="${y}">·</span>`;
            }
        }

        function createOSMFeatureGrid() {
            const grid = Array(MAP_SIZE).fill().map(() => Array(MAP_SIZE).fill(null));
            const metersPerDegreeLat = 111320;
            const metersPerDegreeLon = 111320 * Math.cos(currentLat * Math.PI/180);
            
            osmFeatures.forEach(feature => {
                if (!feature.geometry) return;
                
                const coords = feature.geometry.map(coord => ({
                    x: MAP_SIZE/2 + (coord.lon - currentLon) * metersPerDegreeLon / currentCellSize,
                    y: MAP_SIZE/2 - (coord.lat - currentLat) * metersPerDegreeLat / currentCellSize
                }));
                
                if (feature.tags?.building) {
                    drawPolygonOnGrid(grid, coords, { type: 'building' });
                } else if (feature.tags?.highway) {
                    const isMajor = ['motorway', 'trunk', 'primary'].includes(feature.tags.highway);
                    drawLineOnGrid(grid, coords, { type: isMajor ? 'major-road' : 'road' });
                } else if (feature.tags?.natural === 'water') {
                    drawPolygonOnGrid(grid, coords, { type: 'water' });
                } else if (feature.tags?.leisure === 'park' || feature.tags?.landuse === 'grass') {
                    drawPolygonOnGrid(grid, coords, { type: 'park' });
                } else if (feature.tags?.natural === 'wood' || feature.tags?.landuse === 'forest') {
                    drawPolygonOnGrid(grid, coords, { type: 'forest' });
                }
            });
            
            return grid;
        }

        function drawLineOnGrid(grid, coords, feature) {
            for (let i = 0; i < coords.length - 1; i++) {
                const from = coords[i];
                const to = coords[i + 1];
                drawBresenhamLine(grid, from, to, feature);
            }
        }

        function drawPolygonOnGrid(grid, coords, feature) {
            if (coords.length < 3) return;
            
            // Draw outline
            drawLineOnGrid(grid, coords, feature);
            
            // Fill polygon
            const minY = Math.max(0, Math.floor(Math.min(...coords.map(c => c.y))));
            const maxY = Math.min(MAP_SIZE-1, Math.ceil(Math.max(...coords.map(c => c.y))));
            
            for (let y = minY; y <= maxY; y++) {
                const intersections = [];
                for (let i = 0; i < coords.length; i++) {
                    const from = coords[i];
                    const to = coords[(i + 1) % coords.length];
                    
                    if ((from.y <= y && to.y > y) || (to.y <= y && from.y > y)) {
                        const x = from.x + (to.x - from.x) * (y - from.y) / (to.y - from.y);
                        intersections.push(x);
                    }
                }
                
                intersections.sort((a, b) => a - b);
                for (let i = 0; i < intersections.length; i += 2) {
                    const startX = Math.max(0, Math.floor(intersections[i]));
                    const endX = Math.min(MAP_SIZE-1, Math.ceil(intersections[i + 1] || intersections[i]));
                    
                    for (let x = startX; x <= endX; x++) {
                        if (!grid[y][x]) {
                            grid[y][x] = feature;
                        }
                    }
                }
            }
        }

        function drawBresenhamLine(grid, from, to, feature) {
            let x0 = Math.round(from.x);
            let y0 = Math.round(from.y);
            const x1 = Math.round(to.x);
            const y1 = Math.round(to.y);
            
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = (x0 < x1) ? 1 : -1;
            const sy = (y0 < y1) ? 1 : -1;
            let err = dx - dy;
            
            while (true) {
                if (y0 >= 0 && y0 < MAP_SIZE && x0 >= 0 && x0 < MAP_SIZE) {
                    if (!grid[y0][x0] || grid[y0][x0].type !== 'road') {
                        grid[y0][x0] = feature;
                    }
                }
                
                if (x0 === x1 && y0 === y1) break;
                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }
            }
        }

        // ================ NAVIGATION & ZOOM ================
        function moveMap(dLat, dLon) {
            if (isLoading) return;
            
            currentLat = +(currentLat + dLat).toFixed(6);
            currentLon = +(currentLon + dLon).toFixed(6);
            
            updateCoords();
            fetchElevationData();
        }

        function zoomIn() {
            currentCellSize = Math.max(10, currentCellSize / ZOOM_FACTOR);
            currentMoveDistance = BASE_MOVE_DISTANCE * (BASE_CELL_SIZE / currentCellSize);
            fetchElevationData();
        }

        function zoomOut() {
            currentCellSize = Math.min(500, currentCellSize * ZOOM_FACTOR);
            currentMoveDistance = BASE_MOVE_DISTANCE * (BASE_CELL_SIZE / currentCellSize);
            fetchElevationData();
        }

        function recenter() {
            currentLat = 40.7128;
            currentLon = -74.0060;
            currentCellSize = BASE_CELL_SIZE;
            currentMoveDistance = BASE_MOVE_DISTANCE;
            updateCoords();
            fetchElevationData();
        }

        // ================ LOCATION SERVICES ================
        async function searchAddress() {
            const address = document.getElementById('addressInput').value.trim();
            if (!address) return;
            
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`);
                if (!response.ok) throw new Error("Geocoding failed");
                const results = await response.json();
                
                if (results.length > 0) {
                    currentLat = parseFloat(results[0].lat);
                    currentLon = parseFloat(results[0].lon);
                    updateCoords();
                    fetchElevationData();
                } else {
                    alert("Location not found");
                }
            } catch (e) {
                console.error("Geocoding error:", e);
                alert("Error searching for location");
            }
        }

        function goToCoordinates() {
            const lat = parseFloat(document.getElementById('latInput').value);
            const lon = parseFloat(document.getElementById('lonInput').value);
            
            if (isNaN(lat) || isNaN(lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {
                alert("Please enter valid coordinates\nLatitude: -90 to 90\nLongitude: -180 to 180");
                return;
            }
            
            currentLat = lat;
            currentLon = lon;
            updateCoords();
            fetchElevationData();
        }

        // ================ UTILITY FUNCTIONS ================
        function updateCoords() {
            document.getElementById('coords').textContent = 
                `Latitude: ${currentLat.toFixed(6)}, Longitude: ${currentLon.toFixed(6)}`;
            document.getElementById('latInput').value = currentLat.toFixed(6);
            document.getElementById('lonInput').value = currentLon.toFixed(6);
        }

        async function updateLocationInfo() {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${currentLat}&lon=${currentLon}&zoom=16`);
                const data = await response.json();
                const city = data.address?.city || data.address?.town || data.address?.village || "Unknown";
                const country = data.address?.country || "Unknown";
                document.getElementById('location-info').textContent = `${city}, ${country} | Zoom: ${Math.round(BASE_CELL_SIZE/currentCellSize)}x`;
            } catch (e) {
                document.getElementById('location-info').textContent = `Zoom: ${Math.round(BASE_CELL_SIZE/currentCellSize)}x`;
            }
        }

        function updateStatus(msg) {
            console.log(msg);
        }

        // ================ INTERACTIVITY ================
        function setupMapClickHandler() {
            const mapElement = document.getElementById('map');
            const tooltip = document.getElementById('tooltip');
            
            mapElement.addEventListener('click', (e) => {
                let target = e.target;
                while (target && !target.hasAttribute('data-x')) {
                    target = target.parentElement;
                    if (target === mapElement) return;
                }
                
                if (target && target.hasAttribute('data-x')) {
                    const x = parseInt(target.getAttribute('data-x'));
                    const y = parseInt(target.getAttribute('data-y'));
                    const elev = elevationData[y][x];
                    
                    const metersPerDegreeLat = 111320;
                    const metersPerDegreeLon = 111320 * Math.cos(currentLat * Math.PI/180);
                    const lat = currentLat + (y - MAP_SIZE/2) * (currentCellSize / metersPerDegreeLat);
                    const lon = currentLon + (x - MAP_SIZE/2) * (currentCellSize / metersPerDegreeLon);
                    
                    let featureInfo = "";
                    const osmGrid = createOSMFeatureGrid();
                    if (osmGrid[y] && osmGrid[y][x]) {
                        const feature = osmGrid[y][x];
                        featureInfo = ` (${feature.type})`;
                    }
                    
                    document.getElementById('elevation-info').textContent = 
                        `Elevation: ${elev.toFixed(1)}m${featureInfo} | Coordinates: ${lat.toFixed(6)}, ${lon.toFixed(6)}`;
                }
            });
            
            mapElement.addEventListener('mousemove', (e) => {
                let target = e.target;
                while (target && !target.hasAttribute('data-x')) {
                    target = target.parentElement;
                    if (target === mapElement) return;
                }
                
                if (target && target.hasAttribute('data-x')) {
                    const x = parseInt(target.getAttribute('data-x'));
                    const y = parseInt(target.getAttribute('data-y'));
                    const elev = elevationData[y][x];
                    
                    let featureInfo = "";
                    const osmGrid = createOSMFeatureGrid();
                    if (osmGrid[y] && osmGrid[y][x]) {
                        const feature = osmGrid[y][x];
                        featureInfo = ` (${feature.type})`;
                    }
                    
                    tooltip.style.display = 'block';
                    tooltip.textContent = `${elev.toFixed(1)}m${featureInfo}`;
                    tooltip.style.left = `${e.clientX + 15}px`;
                    tooltip.style.top = `${e.clientY + 15}px`;
                } else {
                    tooltip.style.display = 'none';
                }
            });
            
            mapElement.addEventListener('mouseout', () => {
                tooltip.style.display = 'none';
            });
        }

        // ================ INITIALIZATION ================
        document.getElementById('moveNorth').addEventListener('click', () => moveMap(-currentMoveDistance, 0));
        document.getElementById('moveSouth').addEventListener('click', () => moveMap(currentMoveDistance, 0));
        document.getElementById('moveWest').addEventListener('click', () => moveMap(0, -currentMoveDistance));
        document.getElementById('moveEast').addEventListener('click', () => moveMap(0, currentMoveDistance));
        document.getElementById('recenter').addEventListener('click', recenter);
        document.getElementById('zoomIn').addEventListener('click', zoomIn);
        document.getElementById('zoomOut').addEventListener('click', zoomOut);
        document.getElementById('goToCoords').addEventListener('click', goToCoordinates);
        document.getElementById('searchAddress').addEventListener('click', searchAddress);
        document.getElementById('addressInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') searchAddress();
        });

        setupMapClickHandler();
        fetchElevationData();
    </script>
</body>
</html>
