<!DOCTYPE html>
<html>
<head>
    <title>Fixed ASCII Map with OSM</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #121212;
            color: #e0e0e0;
            text-align: center;
            margin: 0;
            padding: 20px;
        }
        #map-container {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            margin: 0 auto 20px;
            max-width: 1000px;
        }
        #map {
            font-size: 8px;
            line-height: 8px;
            letter-spacing: 1px;
            white-space: pre;
            overflow: auto;
            max-height: 600px;
            padding: 10px;
            background: #222;
            border-radius: 4px;
            cursor: crosshair;
            margin: 0 auto;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }
        button {
            background: #333;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
        }
        .control-panel {
            background: #252525;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            justify-content: center;
            align-items: center;
        }
        input, select {
            background: #252525;
            color: white;
            border: 1px solid #444;
            padding: 8px;
            border-radius: 4px;
            min-width: 120px;
        }
        .info-panel {
            font-family: monospace;
            background: #252525;
            padding: 10px;
            border-radius: 4px;
            margin: 10px auto;
            max-width: 800px;
        }
        /* Map Colors */
        .building { color: #f88; }
        .road { color: #fd5; }
        .major-road { color: #fa0; }
        .water { color: #5af; }
        .park { color: #5c5; }
        .forest { color: #3a5; }
        .ground { color: #ba9; }
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px;
            flex-direction: column;
        }
    </style>
</head>
<body>
    <h1>Fixed ASCII Map with OSM</h1>
    
    <div class="control-panel">
        <div class="input-group">
            <input type="text" id="addressInput" placeholder="Search address">
            <button id="searchAddress">Go</button>
        </div>
        
        <div class="input-group">
            <span>Move:</span>
            <select id="moveDistance">
                <option value="500">500m</option>
                <option value="1000" selected>1km</option>
                <option value="2000">2km</option>
                <option value="5000">5km</option>
            </select>
            
            <span>Zoom:</span>
            <select id="zoomLevel">
                <option value="200">Far (200m/cell)</option>
                <option value="100" selected>Normal (100m/cell)</option>
                <option value="50">Close (50m/cell)</option>
            </select>
        </div>
    </div>
    
    <div class="info-panel">
        <div>Location: <span id="location-info">Loading...</span></div>
        <div>Coordinates: <span id="coords">40.7128, -74.0060</span></div>
        <div>Click map for details: <span id="elevation-info">-</span></div>
    </div>
    
    <div class="controls">
        <div></div>
        <button id="moveNorth">↑ North</button>
        <div></div>
        <button id="moveWest">← West</button>
        <button id="recenter">Reset View</button>
        <button id="moveEast">East →</button>
        <div></div>
        <button id="moveSouth">↓ South</button>
        <div></div>
    </div>
    
    <div id="map-container">
        <div id="map" class="loading">
            Loading map data...
        </div>
    </div>

    <script>
        // ================ CONFIGURATION ================
        const MAP_SIZE = 100; // 100x100 grid
        
        // ================ STATE ================
        let currentLat = 40.7128; // New York
        let currentLon = -74.0060;
        let currentZoom = 100; // Meters per cell
        let currentMove = 1000; // Meters to move
        let mapData = null;

        // ================ MAP FUNCTIONS ================
        async function loadMap() {
            document.getElementById('map').className = 'loading';
            document.getElementById('map').innerHTML = 'Loading map data...';
            
            try {
                // Calculate the area to load
                const metersPerDegree = 111320;
                const latSpan = (currentZoom * MAP_SIZE) / metersPerDegree;
                const lonSpan = (currentZoom * MAP_SIZE) / (metersPerDegree * Math.cos(currentLat * Math.PI/180));
                
                // Get OSM data
                mapData = await getOSMData(
                    currentLat - latSpan/2,
                    currentLon - lonSpan/2,
                    currentLat + latSpan/2,
                    currentLon + lonSpan/2
                );
                
                // Render the map
                renderMap();
                
                // Update location info
                updateLocationInfo();
                
            } catch (error) {
                document.getElementById('map').innerHTML = 'Error loading map';
                console.error(error);
            }
        }
        
        async function getOSMData(minLat, minLon, maxLat, maxLon) {
            const bbox = `${minLon},${minLat},${maxLon},${maxLat}`;
            const query = `
                [out:json];
                (
                    way[building](${bbox});
                    way[highway](${bbox});
                    way[waterway](${bbox});
                    way[natural=water](${bbox});
                    way[leisure=park](${bbox});
                    way[landuse=forest](${bbox});
                    relation[building](${bbox});
                    relation[waterway](${bbox});
                    relation[natural=water](${bbox});
                );
                out geom;
            `;
            
            const response = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`);
            return await response.json();
        }
        
        function renderMap() {
            if (!mapData) return;
            
            // Create empty map grid
            let mapGrid = Array(MAP_SIZE).fill().map(() => Array(MAP_SIZE).fill({type: 'ground', char: '.'}));
            
            // Process all OSM features
            mapData.elements.forEach(feature => {
                if (!feature.geometry) return;
                
                // Convert coordinates to our grid
                const metersPerDegree = 111320;
                const points = feature.geometry.map(coord => {
                    const x = Math.round(MAP_SIZE/2 + (coord.lon - currentLon) * 
                              (metersPerDegree * Math.cos(currentLat * Math.PI/180)) / currentZoom);
                    const y = Math.round(MAP_SIZE/2 - (coord.lat - currentLat) * metersPerDegree / currentZoom);
                    return {x, y};
                }).filter(p => p.x >= 0 && p.x < MAP_SIZE && p.y >= 0 && p.y < MAP_SIZE);
                
                if (points.length === 0) return;
                
                // Determine feature type
                let featureType = 'ground';
                let char = '.';
                
                if (feature.tags?.building) {
                    featureType = 'building';
                    char = '#';
                } 
                else if (feature.tags?.highway) {
                    featureType = feature.tags.highway === 'motorway' ? 'major-road' : 'road';
                    char = featureType === 'major-road' ? '=' : '-';
                }
                else if (feature.tags?.waterway || feature.tags?.natural === 'water') {
                    featureType = 'water';
                    char = '~';
                }
                else if (feature.tags?.leisure === 'park') {
                    featureType = 'park';
                    char = 'P';
                }
                else if (feature.tags?.landuse === 'forest' || feature.tags?.natural === 'wood') {
                    featureType = 'forest';
                    char = 'F';
                }
                
                // Draw lines for linear features
                if (feature.tags?.highway || feature.tags?.waterway) {
                    for (let i = 0; i < points.length-1; i++) {
                        drawLineOnGrid(mapGrid, points[i], points[i+1], {type: featureType, char});
                    }
                } 
                // Draw polygons for area features
                else {
                    drawPolygonOnGrid(mapGrid, points, {type: featureType, char});
                }
            });
            
            // Convert grid to ASCII string
            let mapString = '';
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const cell = mapGrid[y][x];
                    mapString += `<span class="${cell.type}">${cell.char}</span>`;
                }
                mapString += '\n';
            }
            
            document.getElementById('map').innerHTML = mapString;
            document.getElementById('map').className = '';
        }
        
        function drawLineOnGrid(grid, from, to, feature) {
            let x0 = Math.round(from.x);
            let y0 = Math.round(from.y);
            const x1 = Math.round(to.x);
            const y1 = Math.round(to.y);
            
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = (x0 < x1) ? 1 : -1;
            const sy = (y0 < y1) ? 1 : -1;
            let err = dx - dy;
            
            while (true) {
                if (x0 >= 0 && x0 < MAP_SIZE && y0 >= 0 && y0 < MAP_SIZE) {
                    // Only overwrite if not a more important feature
                    if (grid[y0][x0].type === 'ground' || 
                        (grid[y0][x0].type === 'road' && feature.type === 'major-road')) {
                        grid[y0][x0] = feature;
                    }
                }
                
                if (x0 === x1 && y0 === y1) break;
                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }
            }
        }
        
        function drawPolygonOnGrid(grid, points, feature) {
            if (points.length < 3) return;
            
            // Draw outline
            for (let i = 0; i < points.length; i++) {
                const from = points[i];
                const to = points[(i+1)%points.length];
                drawLineOnGrid(grid, from, to, feature);
            }
            
            // Simple fill - scanline algorithm
            const minY = Math.max(0, Math.min(...points.map(p => p.y)));
            const maxY = Math.min(MAP_SIZE-1, Math.max(...points.map(p => p.y)));
            
            for (let y = minY; y <= maxY; y++) {
                const intersections = [];
                for (let i = 0; i < points.length; i++) {
                    const p1 = points[i];
                    const p2 = points[(i+1)%points.length];
                    
                    if ((p1.y <= y && p2.y > y) || (p2.y <= y && p1.y > y)) {
                        const x = p1.x + (p2.x - p1.x) * (y - p1.y) / (p2.y - p1.y);
                        intersections.push(x);
                    }
                }
                
                intersections.sort((a,b) => a - b);
                for (let i = 0; i < intersections.length; i += 2) {
                    const startX = Math.max(0, Math.floor(intersections[i]));
                    const endX = Math.min(MAP_SIZE-1, Math.ceil(intersections[i+1] || intersections[i]));
                    
                    for (let x = startX; x <= endX; x++) {
                        if (grid[y][x].type === 'ground') {
                            grid[y][x] = feature;
                        }
                    }
                }
            }
        }
        
        // ================ NAVIGATION ================
        function moveMap(dLat, dLon) {
            const metersPerDegree = 111320;
            currentLat += (dLat * currentMove) / metersPerDegree;
            currentLon += (dLon * currentMove) / (metersPerDegree * Math.cos(currentLat * Math.PI/180));
            updateCoords();
            loadMap();
        }
        
        function updateControls() {
            currentMove = parseInt(document.getElementById('moveDistance').value);
            currentZoom = parseInt(document.getElementById('zoomLevel').value);
            loadMap();
        }
        
        // ================ LOCATION SERVICES ================
        async function searchAddress() {
            const address = document.getElementById('addressInput').value.trim();
            if (!address) return;
            
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`);
                const results = await response.json();
                
                if (results.length > 0) {
                    currentLat = parseFloat(results[0].lat);
                    currentLon = parseFloat(results[0].lon);
                    updateCoords();
                    loadMap();
                } else {
                    alert("Location not found");
                }
            } catch (e) {
                alert("Error searching for location");
            }
        }
        
        async function updateLocationInfo() {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${currentLat}&lon=${currentLon}&zoom=16`);
                const data = await response.json();
                const location = data.address?.city || data.address?.town || 
                               data.address?.village || data.address?.country || "Unknown";
                document.getElementById('location-info').textContent = location;
            } catch (e) {
                document.getElementById('location-info').textContent = "Unknown";
            }
        }
        
        function updateCoords() {
            document.getElementById('coords').textContent = 
                `${currentLat.toFixed(5)}, ${currentLon.toFixed(5)}`;
        }
        
        // ================ INITIALIZATION ================
        document.getElementById('moveNorth').addEventListener('click', () => moveMap(1, 0));
        document.getElementById('moveSouth').addEventListener('click', () => moveMap(-1, 0));
        document.getElementById('moveWest').addEventListener('click', () => moveMap(0, -1));
        document.getElementById('moveEast').addEventListener('click', () => moveMap(0, 1));
        document.getElementById('recenter').addEventListener('click', () => {
            currentLat = 40.7128;
            currentLon = -74.0060;
            updateCoords();
            loadMap();
        });
        
        document.getElementById('searchAddress').addEventListener('click', searchAddress);
        document.getElementById('addressInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') searchAddress();
        });
        
        document.getElementById('moveDistance').addEventListener('change', updateControls);
        document.getElementById('zoomLevel').addEventListener('change', updateControls);
        
        // Initial load
        loadMap();
    </script>
</body>
</html>
