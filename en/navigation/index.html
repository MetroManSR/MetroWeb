<!DOCTYPE html>
<html>
<head>
    <title>CORS-Free Terrain Map</title>
    <style>
        body { font-family: monospace; background: #111; color: #eee; }
        #map { 
            font-size: 8px;
            line-height: 8px;
            letter-spacing: 1px;
            background: #222;
            padding: 10px;
            white-space: pre;
            overflow: auto;
            max-height: 70vh;
        }
        .water { color: #55f; }
        .sand { color: #db5; }
        .grass { color: #5a5; }
        .forest { color: #0a0; }
        .mountain { color: #aaa; }
        .snow { color: #fff; }
        .road { color: #fc5; }
        .urban { color: #f55; }
        .unknown { color: #777; }
        .loading { color: #aaa; }
    </style>
</head>
<body>
    <h1>Terrain Map (CORS-Free)</h1>
    <div>
        <button id="north">↑</button><br>
        <button id="west">←</button>
        <button id="recenter">◎</button>
        <button id="east">→</button><br>
        <button id="south">↓</button>
    </div>
    <div id="map">Loading...</div>
    <div id="status">Initializing...</div>
    <div id="coords">Lat: 0, Lon: 0</div>

    <script>
        // ===== Configuration =====
        const MAP_SIZE = 40;
        const MOVE_DISTANCE = 0.002; // ~200m
        let currentLat = 48.8566; // Paris
        let currentLon = 2.3522;
        
        // ===== CORS Proxies =====
        const PROXIES = [
            "https://corsproxy.io/?",
            "https://api.allorigins.win/raw?url=",
            "https://thingproxy.freeboard.io/fetch/"
        ];
        
        // ===== Terrain Definitions =====
        const TERRAIN = {
            WATER: { char: '≈', class: 'water', elev: [null, 10] },
            SAND: { char: '░', class: 'sand', elev: [10, 50] },
            GRASS: { char: '·', class: 'grass', elev: [50, 200] },
            FOREST: { char: '♣', class: 'forest', elev: [200, 1000] },
            MOUNTAIN: { char: '△', class: 'mountain', elev: [1000, 3000] },
            SNOW: { char: '❄', class: 'snow', elev: [3000, null] },
            ROAD: { char: '═', class: 'road' },
            URBAN: { char: '█', class: 'urban' }
        };

        // ===== Main Functions =====
        async function generateMap() {
            document.getElementById('map').className = 'loading';
            document.getElementById('map').textContent = 'Loading terrain...';
            updateStatus('Fetching data...');
            updateCoords();
            
            try {
                // Try all data sources with fallbacks
                const [osmData, elevationData] = await Promise.all([
                    fetchOSMData().catch(e => {
                        console.warn("OSM failed:", e);
                        return null;
                    }),
                    fetchElevationData().catch(e => {
                        console.warn("Elevation failed:", e);
                        return null;
                    })
                ]);
                
                renderMap(osmData, elevationData);
                updateStatus('Map ready');
                
            } catch (e) {
                console.error("Map generation failed:", e);
                document.getElementById('map').textContent = 'Error loading map';
                updateStatus('Failed to load map');
            }
        }

        // ===== Data Fetching =====
        async function fetchOSMData() {
            const zoom = 16;
            const tileSize = 256;
            const scale = Math.pow(2, zoom);
            
            const x = Math.floor((currentLon + 180) / 360 * scale);
            const y = Math.floor((1 - Math.log(Math.tan(currentLat * Math.PI / 180) + 
                          1 / Math.cos(currentLat * Math.PI / 180)) / Math.PI / 2 * scale);
            
            // Try all proxies until one works
            for (const proxy of PROXIES) {
                try {
                    const url = `${proxy}https://tile.openstreetmap.org/${zoom}/${x}/${y}.png`;
                    const img = await loadImage(url);
                    return processOSMTile(img);
                } catch (e) {
                    console.warn(`Proxy ${proxy} failed, trying next...`);
                }
            }
            throw new Error("All OSM proxies failed");
        }

        async function fetchElevationData() {
            const points = [];
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    points.push(`${currentLat + y*0.0001},${currentLon + x*0.0001}`);
                }
            }
            
            // Try all proxies for OpenTopoData
            for (const proxy of PROXIES) {
                try {
                    const url = `${proxy}https://api.opentopodata.org/v1/srtm30m?locations=${points.join('|')}`;
                    const response = await fetch(url);
                    const data = await response.json();
                    return data.results.map(r => r.elevation);
                } catch (e) {
                    console.warn(`Elevation proxy ${proxy} failed, trying next...`);
                }
            }
            
            // Final fallback - generate random elevations
            console.warn("Using random elevation fallback");
            return Array(MAP_SIZE*MAP_SIZE).fill().map(() => 
                Math.floor(Math.random() * 4000) - 500 // -500 to 3500m
            );
        }

        // ===== Rendering =====
        function renderMap(osmData, elevationData) {
            let map = '';
            
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const idx = y * MAP_SIZE + x;
                    const elev = elevationData?.[idx];
                    const osm = osmData?.[idx];
                    
                    const terrain = determineTerrain(osm, elev);
                    map += `<span class="${terrain.class}">${terrain.char}</span>`;
                }
                map += '\n';
            }
            
            document.getElementById('map').innerHTML = map;
            document.getElementById('map').className = '';
        }

        function determineTerrain(osmType, elevation) {
            // Priority 1: OSM features
            if (osmType === 'road') return TERRAIN.ROAD;
            if (osmType === 'urban') return TERRAIN.URBAN;
            if (osmType === 'water') return TERRAIN.WATER;
            
            // Priority 2: Elevation-based
            for (const [key, value] of Object.entries(TERRAIN)) {
                if (value.elev) {
                    const [min, max] = value.elev;
                    if ((min === null || elevation >= min) && 
                        (max === null || elevation < max)) {
                        return value;
                    }
                }
            }
            
            return { char: '?', class: 'unknown' };
        }

        // ===== Utilities =====
        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = url;
            });
        }

        function processOSMTile(img) {
            const canvas = new OffscreenCanvas(MAP_SIZE, MAP_SIZE);
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, MAP_SIZE, MAP_SIZE);
            const pixels = ctx.getImageData(0, 0, MAP_SIZE, MAP_SIZE).data;
            
            const result = [];
            for (let i = 0; i < pixels.length; i += 4) {
                const r = pixels[i], g = pixels[i+1], b = pixels[i+2];
                
                if (b > r + 20 && b > g + 20) result.push('water');
                else if (r > 200 && g > 180 && b < 150) result.push('road');
                else if (r > g + 40 && r > b + 40) result.push('urban');
                else result.push(null);
            }
            return result;
        }

        function moveMap(dLat, dLon) {
            currentLat = +(currentLat + dLat).toFixed(6);
            currentLon = +(currentLon + dLon).toFixed(6);
            generateMap();
        }

        function updateCoords() {
            document.getElementById('coords').textContent = 
                `Lat: ${currentLat.toFixed(4)}, Lon: ${currentLon.toFixed(4)}`;
        }

        function updateStatus(msg) {
            document.getElementById('status').textContent = msg;
        }

        // ===== Initialization =====
        document.getElementById('north').addEventListener('click', () => moveMap(-MOVE_DISTANCE, 0));
        document.getElementById('south').addEventListener('click', () => moveMap(MOVE_DISTANCE, 0));
        document.getElementById('west').addEventListener('click', () => moveMap(0, -MOVE_DISTANCE));
        document.getElementById('east').addEventListener('click', () => moveMap(0, MOVE_DISTANCE));
        document.getElementById('recenter').addEventListener('click', () => {
            currentLat = 48.8566;
            currentLon = 2.3522;
            generateMap();
        });

        generateMap();
    </script>
</body>
</html>
