<!DOCTYPE html>
<html>
<head>
    <title>OSM-Focused ASCII Terrain Map</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #121212;
            color: #e0e0e0;
            text-align: center;
            margin: 0;
            padding: 20px;
        }
        #map-container {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            margin-bottom: 20px;
            display: inline-block;
            position: relative;
        }
        #map {
            font-size: 8px;
            line-height: 8px;
            letter-spacing: 1px;
            white-space: pre;
            overflow: auto;
            max-height: 700px;
            max-width: 1000px;
            padding: 10px;
            background: #222;
            border-radius: 4px;
            cursor: crosshair;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }
        button {
            background: #333;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            transition: background 0.2s;
            font-size: 14px;
        }
        .control-group {
            background: #252525;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            justify-content: center;
        }
        input {
            background: #252525;
            color: white;
            border: 1px solid #444;
            padding: 10px;
            border-radius: 4px;
            min-width: 200px;
        }
        #coords, #location-info, #elevation-info {
            font-family: monospace;
            background: #252525;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            display: inline-block;
            font-size: 14px;
        }
        /* OSM Feature Colors */
        .building { color: #f88; }
        .road { color: #fd5; }
        .major-road { color: #fa0; }
        .path { color: #cc9; }
        .water { color: #5af; }
        .park { color: #5c5; }
        .forest { color: #3a5; }
        .elevation-0 { color: #5af; }
        .elevation-1 { color: #8cf; }
        .elevation-2 { color: #acf; }
        .elevation-3 { color: #cdf; }
        .elevation-4 { color: #eef; }
        .elevation-5 { color: #ba9; }
        .elevation-6 { color: #cb9; }
        .elevation-7 { color: #dc9; }
        .elevation-8 { color: #ed9; }
        .elevation-9 { color: #fe9; }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 100;
            font-size: 14px;
            white-space: nowrap;
            font-family: monospace;
        }
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            min-height: 300px;
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #fff;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border: 1px solid #444;
        }
    </style>
</head>
<body>
    <h1>OSM-Focused ASCII Map</h1>
    
    <div class="control-group">
        <div class="input-group">
            <input type="text" id="addressInput" placeholder="Search address or place">
            <button id="searchAddress">Search</button>
        </div>
        
        <div class="input-group">
            <input type="text" id="latInput" placeholder="Latitude" value="40.7128">
            <input type="text" id="lonInput" placeholder="Longitude" value="-74.0060">
            <button id="goToCoords">Go</button>
        </div>
    </div>
    
    <div id="coords">Latitude: 40.7128, Longitude: -74.0060</div>
    <div id="location-info">New York, US</div>
    <div id="elevation-info">Click on the map to see details</div>
    
    <div class="controls">
        <div></div>
        <button id="moveNorth">↑</button>
        <div></div>
        <button id="moveWest">←</button>
        <button id="recenter">◎</button>
        <button id="moveEast">→</button>
        <div></div>
        <button id="moveSouth">↓</button>
        <div></div>
    </div>
    
    <div id="map-container">
        <div id="map" class="loading">
            <div class="loading-spinner"></div>
            <div>Loading OSM data...</div>
        </div>
        <div class="tooltip" id="tooltip" style="display: none;"></div>
    </div>

    <div class="legend">
        <div class="legend-item"><div class="legend-color" style="background: #f88;"></div>Building</div>
        <div class="legend-item"><div class="legend-color" style="background: #fa0;"></div>Major Road</div>
        <div class="legend-item"><div class="legend-color" style="background: #fd5;"></div>Road</div>
        <div class="legend-item"><div class="legend-color" style="background: #cc9;"></div>Path</div>
        <div class="legend-item"><div class="legend-color" style="background: #5af;"></div>Water</div>
        <div class="legend-item"><div class="legend-color" style="background: #5c5;"></div>Park</div>
        <div class="legend-item"><div class="legend-color" style="background: #3a5;"></div>Forest</div>
    </div>

    <script>
        // ================ CONFIGURATION ================
        const MAP_SIZE = 100; // 100x100 grid
        const CELL_SIZE_METERS = 50; // 50m per cell
        const MOVE_DISTANCE = 0.02; // ~2km movement
        const ELEVATION_INTERVAL = 20; // Meters between elevation levels
        
        // ================ STATE MANAGEMENT ================
        let currentLat = 40.7128; // New York
        let currentLon = -74.0060;
        let isLoading = false;
        let elevationData = Array(MAP_SIZE).fill().map(() => Array(MAP_SIZE).fill(0));
        let osmFeatures = [];

        // ================ OSM DATA ================
        async function fetchMapData() {
            isLoading = true;
            document.getElementById('map').className = 'loading';
            
            try {
                // First fetch OSM data
                await fetchOSMData();
                
                // Then fetch elevation data
                await fetchElevationData();
                
                // Render map
                renderMap();
                updateStatus("Map ready");
                updateLocationInfo();
            } catch (error) {
                console.error("Error loading map:", error);
                updateStatus("Error loading map");
            } finally {
                isLoading = false;
            }
        }

        async function fetchOSMData() {
            try {
                const radius = 0.03; // ~3km radius
                const bbox = `${currentLon - radius},${currentLat - radius},${currentLon + radius},${currentLat + radius}`;
                
                const query = `
                    [out:json];
                    (
                        way[building](${bbox});
                        way[highway](${bbox});
                        way[landuse=forest](${bbox});
                        way[leisure=park](${bbox});
                        way[natural=water](${bbox});
                        relation[building](${bbox});
                        relation[landuse=forest](${bbox});
                        relation[leisure=park](${bbox});
                        relation[natural=water](${bbox});
                    );
                    out geom;
                `;
                
                const response = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`);
                if (!response.ok) throw new Error("Failed to fetch OSM data");
                osmFeatures = (await response.json()).elements;
            } catch (e) {
                console.error("Error fetching OSM data:", e);
                osmFeatures = [];
            }
        }

        // ================ ELEVATION DATA ================
        async function fetchElevationData() {
            const metersPerDegreeLat = 111320;
            const metersPerDegreeLon = 111320 * Math.cos(currentLat * Math.PI/180);
            
            // Prepare elevation points to fetch
            const locations = [];
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const lat = currentLat + (y - MAP_SIZE/2) * (CELL_SIZE_METERS / metersPerDegreeLat);
                    const lon = currentLon + (x - MAP_SIZE/2) * (CELL_SIZE_METERS / metersPerDegreeLon);
                    locations.push({ latitude: lat, longitude: lon, x, y });
                }
            }
            
            // Fetch elevation data
            const elevations = await getElevations(locations);
            
            // Store elevations
            elevations.forEach((elev, index) => {
                const {x, y} = locations[index];
                elevationData[y][x] = elev;
            });
        }

        async function getElevations(locations) {
            try {
                // Try Open-Elevation API first
                const response = await fetch('https://api.open-elevation.com/api/v1/lookup', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        locations: locations.map(loc => ({ 
                            latitude: loc.latitude, 
                            longitude: loc.longitude 
                        }))
                    })
                });
                
                if (!response.ok) throw new Error("Elevation API failed");
                const data = await response.json();
                return data.results.map(r => r.elevation);
            } catch (e) {
                console.error("Using fallback elevation service:", e);
                // Fallback to random elevations if API fails
                return locations.map(() => Math.random() * 200);
            }
        }

        // ================ RENDERING ================
        function renderMap() {
            let mapOutput = '';
            const osmGrid = createOSMFeatureGrid();
            
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    // Prioritize OSM features
                    if (osmGrid[y] && osmGrid[y][x]) {
                        const feature = osmGrid[y][x];
                        if (feature.type === 'water') {
                            mapOutput += `<span class="water">≈</span>`;
                        } else if (feature.type === 'road') {
                            mapOutput += `<span class="road">─</span>`;
                        } else if (feature.type === 'major-road') {
                            mapOutput += `<span class="major-road">═</span>`;
                        } else if (feature.type === 'path') {
                            mapOutput += `<span class="path">·</span>`;
                        } else if (feature.type === 'building') {
                            mapOutput += `<span class="building">█</span>`;
                        } else if (feature.type === 'park') {
                            mapOutput += `<span class="park">♣</span>`;
                        } else if (feature.type === 'forest') {
                            mapOutput += `<span class="forest">♠</span>`;
                        } else {
                            mapOutput += getElevationCell(x, y);
                        }
                    } else {
                        mapOutput += getElevationCell(x, y);
                    }
                }
                mapOutput += '\n';
            }
            
            document.getElementById('map').innerHTML = mapOutput;
            document.getElementById('map').className = '';
        }

        function getElevationCell(x, y) {
            const elev = elevationData[y][x];
            const level = Math.floor(elev / ELEVATION_INTERVAL) % 10;
            
            // Use different characters for different elevation levels
            const chars = [' ', '.', ':', 'i', 'I', 'n', 'm', 'M', 'W', '#'];
            return `<span class="elevation-${level}" data-x="${x}" data-y="${y}">${chars[level]}</span>`;
        }

        function createOSMFeatureGrid() {
            const grid = Array(MAP_SIZE).fill().map(() => Array(MAP_SIZE).fill(null));
            const metersPerDegreeLat = 111320;
            const metersPerDegreeLon = 111320 * Math.cos(currentLat * Math.PI/180);
            
            osmFeatures.forEach(feature => {
                if (!feature.geometry) return;
                
                const coords = feature.geometry.map(coord => ({
                    x: MAP_SIZE/2 + (coord.lon - currentLon) * metersPerDegreeLon / CELL_SIZE_METERS,
                    y: MAP_SIZE/2 - (coord.lat - currentLat) * metersPerDegreeLat / CELL_SIZE_METERS
                }));
                
                if (feature.tags?.building) {
                    drawPolygonOnGrid(grid, coords, { type: 'building' });
                } else if (feature.tags?.highway) {
                    const isMajor = ['motorway', 'trunk', 'primary', 'secondary'].includes(feature.tags.highway);
                    const isPath = ['path', 'footway', 'pedestrian', 'steps'].includes(feature.tags.highway);
                    if (isPath) {
                        drawLineOnGrid(grid, coords, { type: 'path' });
                    } else {
                        drawLineOnGrid(grid, coords, { type: isMajor ? 'major-road' : 'road' });
                    }
                } else if (feature.tags?.natural === 'water' || feature.tags?.waterway) {
                    drawPolygonOnGrid(grid, coords, { type: 'water' });
                } else if (feature.tags?.leisure === 'park' || feature.tags?.landuse === 'grass') {
                    drawPolygonOnGrid(grid, coords, { type: 'park' });
                } else if (feature.tags?.natural === 'wood' || feature.tags?.landuse === 'forest') {
                    drawPolygonOnGrid(grid, coords, { type: 'forest' });
                }
            });
            
            return grid;
        }

        function drawLineOnGrid(grid, coords, feature) {
            for (let i = 0; i < coords.length - 1; i++) {
                const from = coords[i];
                const to = coords[i + 1];
                drawBresenhamLine(grid, from, to, feature);
            }
        }

        function drawPolygonOnGrid(grid, coords, feature) {
            if (coords.length < 3) return;
            
            // Draw outline
            drawLineOnGrid(grid, coords, feature);
            
            // Fill polygon
            const minY = Math.max(0, Math.floor(Math.min(...coords.map(c => c.y))));
            const maxY = Math.min(MAP_SIZE-1, Math.ceil(Math.max(...coords.map(c => c.y))));
            
            for (let y = minY; y <= maxY; y++) {
                const intersections = [];
                for (let i = 0; i < coords.length; i++) {
                    const from = coords[i];
                    const to = coords[(i + 1) % coords.length];
                    
                    if ((from.y <= y && to.y > y) || (to.y <= y && from.y > y)) {
                        const x = from.x + (to.x - from.x) * (y - from.y) / (to.y - from.y);
                        intersections.push(x);
                    }
                }
                
                intersections.sort((a, b) => a - b);
                for (let i = 0; i < intersections.length; i += 2) {
                    const startX = Math.max(0, Math.floor(intersections[i]));
                    const endX = Math.min(MAP_SIZE-1, Math.ceil(intersections[i + 1] || intersections[i]));
                    
                    for (let x = startX; x <= endX; x++) {
                        if (!grid[y][x]) {
                            grid[y][x] = feature;
                        }
                    }
                }
            }
        }

        function drawBresenhamLine(grid, from, to, feature) {
            let x0 = Math.round(from.x);
            let y0 = Math.round(from.y);
            const x1 = Math.round(to.x);
            const y1 = Math.round(to.y);
            
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = (x0 < x1) ? 1 : -1;
            const sy = (y0 < y1) ? 1 : -1;
            let err = dx - dy;
            
            while (true) {
                if (y0 >= 0 && y0 < MAP_SIZE && x0 >= 0 && x0 < MAP_SIZE) {
                    if (!grid[y0][x0] || (grid[y0][x0].type !== 'building' && grid[y0][x0].type !== 'water')) {
                        grid[y0][x0] = feature;
                    }
                }
                
                if (x0 === x1 && y0 === y1) break;
                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }
            }
        }

        // ================ INTERACTIVITY ================
        function setupMapClickHandler() {
            const mapElement = document.getElementById('map');
            const tooltip = document.getElementById('tooltip');
            
            mapElement.addEventListener('click', (e) => {
                let target = e.target;
                while (target && !target.hasAttribute('data-x')) {
                    target = target.parentElement;
                    if (target === mapElement) return;
                }
                
                if (target && target.hasAttribute('data-x')) {
                    const x = parseInt(target.getAttribute('data-x'));
                    const y = parseInt(target.getAttribute('data-y'));
                    const elev = elevationData[y][x];
                    
                    const metersPerDegreeLat = 111320;
                    const metersPerDegreeLon = 111320 * Math.cos(currentLat * Math.PI/180);
                    const lat = currentLat + (y - MAP_SIZE/2) * (CELL_SIZE_METERS / metersPerDegreeLat);
                    const lon = currentLon + (x - MAP_SIZE/2) * (CELL_SIZE_METERS / metersPerDegreeLon);
                    
                    let featureInfo = "";
                    const osmGrid = createOSMFeatureGrid();
                    if (osmGrid[y] && osmGrid[y][x]) {
                        const feature = osmGrid[y][x];
                        featureInfo = ` (${feature.type})`;
                    }
                    
                    document.getElementById('elevation-info').textContent = 
                        `Elevation: ${elev.toFixed(1)}m${featureInfo} | Coordinates: ${lat.toFixed(6)}, ${lon.toFixed(6)}`;
                }
            });
            
            mapElement.addEventListener('mousemove', (e) => {
                let target = e.target;
                while (target && !target.hasAttribute('data-x')) {
                    target = target.parentElement;
                    if (target === mapElement) return;
                }
                
                if (target && target.hasAttribute('data-x')) {
                    const x = parseInt(target.getAttribute('data-x'));
                    const y = parseInt(target.getAttribute('data-y'));
                    const elev = elevationData[y][x];
                    
                    let featureInfo = "";
                    const osmGrid = createOSMFeatureGrid();
                    if (osmGrid[y] && osmGrid[y][x]) {
                        const feature = osmGrid[y][x];
                        featureInfo = ` (${feature.type})`;
                    }
                    
                    tooltip.style.display = 'block';
                    tooltip.textContent = `${elev.toFixed(1)}m${featureInfo}`;
                    tooltip.style.left = `${e.clientX + 15}px`;
                    tooltip.style.top = `${e.clientY + 15}px`;
                } else {
                    tooltip.style.display = 'none';
                }
            });
            
            mapElement.addEventListener('mouseout', () => {
                tooltip.style.display = 'none';
            });
        }

        // ================ NAVIGATION ================
        function moveMap(dLat, dLon) {
            if (isLoading) return;
            
            currentLat = +(currentLat + dLat).toFixed(6);
            currentLon = +(currentLon + dLon).toFixed(6);
            
            updateCoords();
            fetchMapData();
        }

        function recenter() {
            currentLat = 40.7128;
            currentLon = -74.0060;
            updateCoords();
            fetchMapData();
        }

        // ================ LOCATION SERVICES ================
        async function searchAddress() {
            const address = document.getElementById('addressInput').value.trim();
            if (!address) return;
            
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`);
                if (!response.ok) throw new Error("Geocoding failed");
                const results = await response.json();
                
                if (results.length > 0) {
                    currentLat = parseFloat(results[0].lat);
                    currentLon = parseFloat(results[0].lon);
                    updateCoords();
                    fetchMapData();
                } else {
                    alert("Location not found");
                }
            } catch (e) {
                console.error("Geocoding error:", e);
                alert("Error searching for location");
            }
        }

        function goToCoordinates() {
            const lat = parseFloat(document.getElementById('latInput').value);
            const lon = parseFloat(document.getElementById('lonInput').value);
            
            if (isNaN(lat) || isNaN(lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {
                alert("Please enter valid coordinates\nLatitude: -90 to 90\nLongitude: -180 to 180");
                return;
            }
            
            currentLat = lat;
            currentLon = lon;
            updateCoords();
            fetchMapData();
        }

        // ================ UTILITY FUNCTIONS ================
        function updateCoords() {
            document.getElementById('coords').textContent = 
                `Latitude: ${currentLat.toFixed(6)}, Longitude: ${currentLon.toFixed(6)}`;
            document.getElementById('latInput').value = currentLat.toFixed(6);
            document.getElementById('lonInput').value = currentLon.toFixed(6);
        }

        async function updateLocationInfo() {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${currentLat}&lon=${currentLon}&zoom=16`);
                const data = await response.json();
                const city = data.address?.city || data.address?.town || data.address?.village || "Unknown";
                const country = data.address?.country || "Unknown";
                document.getElementById('location-info').textContent = `${city}, ${country}`;
            } catch (e) {
                document.getElementById('location-info').textContent = "";
            }
        }

        function updateStatus(msg) {
            console.log(msg);
        }

        // ================ INITIALIZATION ================
        document.getElementById('moveNorth').addEventListener('click', () => moveMap(-MOVE_DISTANCE, 0));
        document.getElementById('moveSouth').addEventListener('click', () => moveMap(MOVE_DISTANCE, 0));
        document.getElementById('moveWest').addEventListener('click', () => moveMap(0, -MOVE_DISTANCE));
        document.getElementById('moveEast').addEventListener('click', () => moveMap(0, MOVE_DISTANCE));
        document.getElementById('recenter').addEventListener('click', recenter);
        document.getElementById('goToCoords').addEventListener('click', goToCoordinates);
        document.getElementById('searchAddress').addEventListener('click', searchAddress);
        document.getElementById('addressInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') searchAddress();
        });

        setupMapClickHandler();
        fetchMapData();
    </script>
</body>
</html>
