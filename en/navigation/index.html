<!DOCTYPE html>
<html>
<head>
    <title>Reliable OSM+SRTM Terrain Map</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #121212;
            color: #e0e0e0;
            text-align: center;
            margin: 0;
            padding: 20px;
        }
        #map-container {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            margin-bottom: 20px;
            display: inline-block;
        }
        #map {
            font-size: 8px;
            line-height: 8px;
            letter-spacing: 1px;
            white-space: pre;
            overflow: auto;
            max-height: 500px;
            padding: 10px;
            background: #222;
            border-radius: 4px;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
            max-width: 300px;
            margin-left: auto;
            margin-right: auto;
        }
        button {
            background: #333;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            transition: background 0.2s;
        }
        button:hover {
            background: #444;
        }
        button:active {
            background: #555;
        }
        .nav-btn {
            font-size: 16px;
            padding: 10px;
        }
        #coords {
            font-family: monospace;
            background: #252525;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 10px;
            display: inline-block;
        }
        #status {
            color: #aaa;
            font-size: 14px;
            margin-top: 10px;
        }
        /* Terrain Colors */
        .water { color: #5af; }
        .sand { color: #db5; }
        .grass { color: #5c5; }
        .forest { color: #0a0; }
        .rock { color: #aaa; }
        .snow { color: #fff; text-shadow: 0 0 2px #fff; }
        .road { color: #fd5; }
        .urban { color: #f88; }
        .unknown { color: #777; }
        .loading { color: #666; }
    </style>
</head>
<body>
    <h1>Reliable Terrain Map</h1>
    
    <div id="coords">Latitude: 48.8566, Longitude: 2.3522</div>
    
    <div class="controls">
        <div></div>
        <button class="nav-btn" id="moveNorth">↑</button>
        <div></div>
        <button class="nav-btn" id="moveWest">←</button>
        <button id="recenter">◎</button>
        <button class="nav-btn" id="moveEast">→</button>
        <div></div>
        <button class="nav-btn" id="moveSouth">↓</button>
        <div></div>
    </div>
    
    <div id="map-container">
        <div id="map" class="loading">Loading terrain data...</div>
    </div>
    
    <div id="status">Initializing...</div>

    <script>
        // ================ CONFIGURATION ================
        const MAP_SIZE = 40; // 40x40 characters
        const CELL_RESOLUTION = 0.0002; // Degrees per cell (~20m at equator)
        const MOVE_DISTANCE = 0.001; // Degrees per movement (~100m)
        
        // ================ STATE MANAGEMENT ================
        let currentLat = 48.8566; // Paris
        let currentLon = 2.3522;
        let isLoading = false;
        let srtmCache = {};
        let osmCache = {};

        // ================ TERRAIN MAPPING ================
        const TERRAIN_TYPES = {
            WATER: { char: '≈', class: 'water', priority: 1 },
            SAND: { char: '░', class: 'sand', priority: 2 },
            GRASS: { char: '·', class: 'grass', priority: 3 },
            FOREST: { char: '♣', class: 'forest', priority: 4 },
            ROCK: { char: '○', class: 'rock', priority: 5 },
            SNOW: { char: '❄', class: 'snow', priority: 6 },
            ROAD: { char: '═', class: 'road', priority: 7 },
            URBAN: { char: '█', class: 'urban', priority: 8 },
            UNKNOWN: { char: '?', class: 'unknown', priority: 0 }
        };

        // ================ CORE FUNCTIONS ================
        async function generateMap() {
            if (isLoading) return;
            isLoading = true;
            
            const startTime = performance.now();
            updateStatus("Loading terrain data...");
            updateCoords();
            document.getElementById('map').className = 'loading';
            document.getElementById('map').textContent = 'Loading...';
            
            try {
                // Try both data sources with fallbacks
                const [osmData, elevationData] = await Promise.all([
                    fetchOSMData().catch(handleOSMFailure),
                    fetchElevationData().catch(handleElevationFailure)
                ]);
                
                renderMap(osmData, elevationData);
                
                const loadTime = performance.now() - startTime;
                updateStatus(`Map generated in ${loadTime.toFixed(0)}ms | ` +
                           `${osmData ? "OSM ✓" : "OSM ✗"} | ` +
                           `${elevationData ? "Elevation ✓" : "Elevation ✗"}`);
                
            } catch (error) {
                console.error("Map generation failed:", error);
                updateStatus("Failed to generate map");
                document.getElementById('map').textContent = "Error: Could not load map data";
            } finally {
                isLoading = false;
            }
        }

        // ================ DATA FETCHING ================
        async function fetchOSMData() {
            const zoom = 16; // Detailed zoom level
            const scale = Math.pow(2, zoom);
            
            // Convert to tile coordinates
            const x = Math.floor((currentLon + 180) / 360 * scale);
            const y = Math.floor(1 - Math.log(Math.tan(currentLat * Math.PI / 180) + 
                          1 / Math.cos(currentLat * Math.PI / 180)) / Math.PI / 2 * scale);
            
            const cacheKey = `${zoom}_${x}_${y}`;
            if (osmCache[cacheKey]) return osmCache[cacheKey];
            
            try {
                // Use CORS proxy for OSM tiles
                const proxyUrl = `https://corsproxy.io/?https://tile.openstreetmap.org/${zoom}/${x}/${y}.png`;
                const img = await loadImageWithTimeout(proxyUrl, 5000);
                
                const canvas = new OffscreenCanvas(MAP_SIZE, MAP_SIZE);
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, MAP_SIZE, MAP_SIZE);
                const pixelData = ctx.getImageData(0, 0, MAP_SIZE, MAP_SIZE).data;
                
                const result = [];
                for (let i = 0; i < pixelData.length; i += 4) {
                    const [r, g, b] = pixelData.slice(i, i + 3);
                    
                    // Color detection for OSM features
                    if (b > r + 30 && b > g + 30) result.push('water');
                    else if (r > 200 && g > 180 && b < 150) result.push('road');
                    else if (r > g + 50 && r > b + 50) result.push('urban');
                    else if (g > r + 30 && g > b + 30) result.push('forest');
                    else result.push(null);
                }
                
                osmCache[cacheKey] = result;
                return result;
            } catch (error) {
                throw new Error(`OSM tiles failed: ${error.message}`);
            }
        }

        async function fetchElevationData() {
            // Generate grid of points
            const points = [];
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    points.push({
                        lat: currentLat + y * CELL_RESOLUTION,
                        lon: currentLon + x * CELL_RESOLUTION
                    });
                }
            }
            
            // Use SRTM tiles with multiple fallback sources
            const elevations = new Array(MAP_SIZE * MAP_SIZE).fill(null);
            let loadedCount = 0;
            
            for (let i = 0; i < points.length; i++) {
                const {lat, lon} = points[i];
                const tileLat = Math.floor(lat);
                const tileLon = Math.floor(lon);
                const tileKey = `${tileLat}_${tileLon}`;
                
                // Try to get elevation from cache or load new tile
                try {
                    if (!srtmCache[tileKey]) {
                        await loadSRTMTile(tileLat, tileLon);
                    }
                    
                    if (srtmCache[tileKey]) {
                        const tile = srtmCache[tileKey];
                        const x = Math.floor((lon - tileLon) * tile.width);
                        const y = Math.floor((tileLat + 1 - lat) * tile.height);
                        const idx = y * tile.width + x;
                        
                        if (idx >= 0 && idx < tile.data.length) {
                            elevations[i] = tile.data[idx];
                        }
                    }
                } catch (e) {
                    console.warn(`Error processing point ${i}:`, e);
                }
                
                loadedCount++;
                
                // Update progress periodically
                if (loadedCount % 50 === 0) {
                    updateStatus(`Loading elevation... ${loadedCount}/${points.length}`);
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            return elevations;
        }

        async function loadSRTMTile(tileLat, tileLon) {
            const tileKey = `${tileLat}_${tileLon}`;
            if (srtmCache[tileKey]) return;
            
            // Try multiple SRTM sources
            const sources = [
                `https://s3.amazonaws.com/elevation-tiles-prod/geotiff/${Math.abs(tileLat)}${tileLat >= 0 ? 'N' : 'S'}${Math.abs(tileLon)}${tileLon >= 0 ? 'E' : 'W'}.tif`,
                `https://opentopography.s3.sdsc.edu/raster/SRTM_GL1/SRTM_GL1_srtm/${Math.abs(tileLat)}${tileLat >= 0 ? 'N' : 'S'}${Math.abs(tileLon)}${tileLon >= 0 ? 'E' : 'W'}.hgt.zip`
            ];
            
            for (const source of sources) {
                try {
                    const response = await fetch(source);
                    if (!response.ok) continue;
                    
                    const arrayBuffer = await response.arrayBuffer();
                    const tiff = await parseGeoTIFF(arrayBuffer);
                    const image = await tiff.getImage();
                    const rasters = await image.readRasters();
                    
                    srtmCache[tileKey] = {
                        width: image.getWidth(),
                        height: image.getHeight(),
                        data: rasters[0]
                    };
                    return;
                } catch (e) {
                    console.warn(`Failed to load SRTM from ${source}:`, e);
                }
            }
            
            throw new Error(`All SRTM sources failed for tile ${tileKey}`);
        }

        // ================ RENDERING ================
        function renderMap(osmData, elevationData) {
            let mapOutput = '';
            
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const idx = y * MAP_SIZE + x;
                    const elev = elevationData?.[idx] ?? 0;
                    const osmFeature = osmData?.[idx];
                    
                    const terrain = determineTerrain(osmFeature, elev);
                    mapOutput += `<span class="${terrain.class}">${terrain.char}</span>`;
                }
                mapOutput += '\n';
            }
            
            document.getElementById('map').innerHTML = mapOutput;
            document.getElementById('map').className = '';
        }

        function determineTerrain(osmFeature, elevation) {
            // First check OSM features
            if (osmFeature === 'water') return TERRAIN_TYPES.WATER;
            if (osmFeature === 'road') return TERRAIN_TYPES.ROAD;
            if (osmFeature === 'urban') return TERRAIN_TYPES.URBAN;
            if (osmFeature === 'forest') return TERRAIN_TYPES.FOREST;
            
            // Fall back to elevation-based terrain
            if (elevation === null) return TERRAIN_TYPES.UNKNOWN;
            if (elevation < 10) return TERRAIN_TYPES.WATER;
            if (elevation < 50) return TERRAIN_TYPES.SAND;
            if (elevation < 200) return TERRAIN_TYPES.GRASS;
            if (elevation < 1000) return TERRAIN_TYPES.FOREST;
            if (elevation < 3000) return TERRAIN_TYPES.ROCK;
            return TERRAIN_TYPES.SNOW;
        }

        // ================ UTILITIES ================
        async function loadImageWithTimeout(url, timeout) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const timer = setTimeout(() => {
                    reject(new Error(`Image load timed out after ${timeout}ms`));
                }, timeout);
                
                img.onload = () => {
                    clearTimeout(timer);
                    resolve(img);
                };
                img.onerror = () => {
                    clearTimeout(timer);
                    reject(new Error("Failed to load image"));
                };
                img.crossOrigin = "Anonymous";
                img.src = url;
            });
        }

        function handleOSMFailure(error) {
            console.warn("OSM data unavailable:", error.message);
            return null;
        }

        function handleElevationFailure(error) {
            console.warn("Elevation data unavailable:", error.message);
            return null;
        }

        function moveMap(dLat, dLon) {
            currentLat = parseFloat((currentLat + dLat).toFixed(6));
            currentLon = parseFloat((currentLon + dLon).toFixed(6));
            
            // Ensure valid coordinate ranges
            currentLat = Math.max(-90, Math.min(90, currentLat));
            currentLon = Math.max(-180, Math.min(180, currentLon));
            
            generateMap();
        }

        function updateCoords() {
            document.getElementById('coords').textContent = 
                `Latitude: ${currentLat.toFixed(4)}, Longitude: ${currentLon.toFixed(4)}`;
        }

        function updateStatus(msg) {
            document.getElementById('status').textContent = msg;
        }

        function recenter() {
            currentLat = 48.8566;
            currentLon = 2.3522;
            generateMap();
        }

        // ================ GeoTIFF Parser ================
        async function parseGeoTIFF(arrayBuffer) {
            const view = new DataView(arrayBuffer);
            
            // Check byte order
            const littleEndian = view.getUint16(0, true) === 0x4949;
            
            // Read IFD offset
            const ifdOffset = view.getUint32(4, littleEndian);
            
            return {
                getImage: async function() {
                    const numEntries = view.getUint16(ifdOffset, littleEndian);
                    let offset = ifdOffset + 2;
                    
                    let width, height, stripOffsets, stripByteCounts;
                    
                    for (let i = 0; i < numEntries; i++) {
                        const tag = view.getUint16(offset, littleEndian);
                        const type = view.getUint16(offset + 2, littleEndian);
                        const count = view.getUint32(offset + 4, littleEndian);
                        let valueOffset = offset + 8;
                        
                        if (getTypeSize(type) * count > 4) {
                            valueOffset = view.getUint32(valueOffset, littleEndian);
                        }
                        
                        switch (tag) {
                            case 256: width = readValue(type, count, valueOffset); break;
                            case 257: height = readValue(type, count, valueOffset); break;
                            case 273: stripOffsets = readValue(type, count, valueOffset); break;
                            case 279: stripByteCounts = readValue(type, count, valueOffset); break;
                        }
                        
                        offset += 12;
                    }
                    
                    return {
                        getWidth: () => width,
                        getHeight: () => height,
                        readRasters: async function() {
                            const data = new Int16Array(width * height);
                            let pos = 0;
                            
                            for (let i = 0; i < stripOffsets.length; i++) {
                                const stripOffset = stripOffsets[i];
                                const stripLength = stripByteCounts[i];
                                
                                for (let j = 0; j < stripLength/2; j++) {
                                    const byteOffset = stripOffset + j*2;
                                    if (byteOffset + 2 <= view.byteLength) {
                                        data[pos++] = view.getInt16(byteOffset, littleEndian);
                                    } else {
                                        data[pos++] = 0; // Safe default for out of bounds
                                    }
                                }
                            }
                            
                            return [data];
                        }
                    };
                }
            };
            
            function readValue(type, count, offset) {
                const size = getTypeSize(type);
                const values = [];
                
                for (let i = 0; i < count; i++) {
                    switch (type) {
                        case 3: values.push(view.getUint16(offset, littleEndian)); break;
                        case 4: values.push(view.getUint32(offset, littleEndian)); break;
                        default: values.push(0);
                    }
                    offset += size;
                }
                
                return count === 1 ? values[0] : values;
            }
            
            function getTypeSize(type) {
                return type === 3 ? 2 : 4; // Only handle SHORT and LONG
            }
        }

        // ================ INITIALIZATION ================
        document.getElementById('moveNorth').addEventListener('click', () => moveMap(-MOVE_DISTANCE, 0));
        document.getElementById('moveSouth').addEventListener('click', () => moveMap(MOVE_DISTANCE, 0));
        document.getElementById('moveWest').addEventListener('click', () => moveMap(0, -MOVE_DISTANCE));
        document.getElementById('moveEast').addEventListener('click', () => moveMap(0, MOVE_DISTANCE));
        document.getElementById('recenter').addEventListener('click', recenter);

        // Start loading
        generateMap();
    </script>
</body>
</html>
