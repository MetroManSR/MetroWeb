<!DOCTYPE html>
<html>
<head>
    <title>3D Terrain with OSM Data</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
        #controls {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.7); padding: 10px; color: white;
            border-radius: 5px; z-index: 10;
        }
        button { margin: 5px; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
    <div id="controls">
        <input type="text" id="addressInput" placeholder="Search address">
        <button id="searchAddress">Search</button>
        <div>Coordinates: <span id="coords">-33.4550, -70.6600</span></div>
    </div>
    <div id="loading">Loading...</div>
    <canvas id="renderCanvas"></canvas>

    <script>
        // ================ GLOBALS ================
        let scene;
        let engine;
        let currentLat = -33.4550;
        let currentLon = -70.6600;
        const TERRAIN_SIZE = 1000; // Meters

        // ================ INIT BABYLON ================
        const initEngine = () => {
            const canvas = document.getElementById("renderCanvas");
            engine = new BABYLON.Engine(canvas, true);
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.2, 1);

            // Camera
            const camera = new BABYLON.ArcRotateCamera(
                "camera", 
                -Math.PI / 2, Math.PI / 4, 500, 
                new BABYLON.Vector3(0, 0, 0), 
                scene
            );
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 100;
            camera.upperRadiusLimit = 2000;

            // Light
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.8;

            return { scene, engine, camera };
        };

        // ================ TERRAIN ================
        const createTerrain = (elevationData) => {
            const subdivisions = 100;
            const terrain = BABYLON.MeshBuilder.CreateGroundFromHeightMap(
                "terrain",
                createHeightMapTexture(elevationData, subdivisions),
                {
                    width: TERRAIN_SIZE,
                    height: TERRAIN_SIZE,
                    subdivisions,
                    minHeight: 0,
                    maxHeight: 100
                },
                scene
            );

            // Material
            const terrainMat = new BABYLON.StandardMaterial("terrainMat", scene);
            terrainMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/grass.png", scene);
            terrain.material = terrainMat;

            return terrain;
        };

        const createHeightMapTexture = (data, size) => {
            const canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext("2d");
            const imageData = ctx.createImageData(size, size);

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const idx = (y * size + x) * 4;
                    const elevation = data[y]?.[x] || 0;
                    const val = Math.floor((elevation / 100) * 255);
                    imageData.data[idx] = val;
                    imageData.data[idx+1] = val;
                    imageData.data[idx+2] = val;
                    imageData.data[idx+3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        };

        // ================ OSM RENDERING ================
        const fetchOSMData = async (lat, lon, radius = 500) => {
            const overpassUrl = `https://overpass-api.de/api/interpreter?data=
                [out:json];
                (
                    way[~"highway"~"motorway|trunk|primary|secondary|tertiary|residential"]
                    (around:${radius},${lat},${lon});
                    way["building"](around:${radius},${lat},${lon});
                );
                out geom;`;

            try {
                const response = await fetch(overpassUrl);
                return await response.json();
            } catch (error) {
                console.error("OSM Error:", error);
                return { elements: [] };
            }
        };

        const renderOSMFeatures = (elements) => {
            elements.forEach(element => {
                if (element.tags?.highway) {
                    createRoad(element.geometry, element.tags.highway.includes("motorway"));
                } else if (element.tags?.building) {
                    createBuilding(element.geometry);
                }
            });
        };

        const createRoad = (geometry, isMajor) => {
            const points = geometry.map(pt => 
                new BABYLON.Vector3(
                    (pt.lon - currentLon) * 111320, 
                    0.5, 
                    -(pt.lat - currentLat) * 111320
                )
            );

            const road = BABYLON.MeshBuilder.CreateTube("road", {
                path: points,
                radius: isMajor ? 5 : 3,
                tessellation: 4
            }, scene);

            const mat = new BABYLON.StandardMaterial("roadMat", scene);
            mat.diffuseColor = isMajor ? new BABYLON.Color3(0.9, 0.5, 0) : new BABYLON.Color3(0.8, 0.8, 0.6);
            road.material = mat;
        };

        const createBuilding = (geometry) => {
            const baseHeight = 10 + Math.random() * 20;
            const polygon = geometry.map(pt => 
                new BABYLON.Vector3(
                    (pt.lon - currentLon) * 111320, 
                    0, 
                    -(pt.lat - currentLat) * 111320
                )
            );

            const building = BABYLON.MeshBuilder.ExtrudePolygon("building", {
                shape: polygon,
                depth: baseHeight
            }, scene);

            building.position.y = baseHeight / 2;
            const mat = new BABYLON.StandardMaterial("buildingMat", scene);
            mat.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7);
            building.material = mat;
        };

        // ================ MAIN LOGIC ================
        const loadMap = async () => {
            document.getElementById("loading").style.display = "block";
            
            try {
                // Clear old scene
                scene.getMeshes().forEach(mesh => mesh.dispose());
                
                // Generate terrain (mock elevation)
                const elevationData = generateMockElevation();
                createTerrain(elevationData);

                // Fetch and render OSM
                const osmData = await fetchOSMData(currentLat, currentLon);
                renderOSMFeatures(osmData.elements);

                updateCoords();
            } catch (error) {
                console.error("Load error:", error);
            } finally {
                document.getElementById("loading").style.display = "none";
            }
        };

        const generateMockElevation = () => {
            const size = 100;
            const data = [];
            for (let y = 0; y < size; y++) {
                data[y] = [];
                for (let x = 0; x < size; x++) {
                    data[y][x] = 30 * Math.sin(x/10) * Math.cos(y/10) + 50;
                }
            }
            return data;
        };

        // ================ UI CONTROLS ================
        const updateCoords = () => {
            document.getElementById("coords").textContent = 
                `${currentLat.toFixed(5)}, ${currentLon.toFixed(5)}`;
        };

        const searchAddress = async () => {
            const address = document.getElementById("addressInput").value;
            if (!address) return;
            
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`
                );
                const data = await response.json();
                if (data.length > 0) {
                    currentLat = parseFloat(data[0].lat);
                    currentLon = parseFloat(data[0].lon);
                    await loadMap();
                }
            } catch (error) {
                console.error("Geocoding error:", error);
            }
        };

        // ================ INIT ================
        window.addEventListener("DOMContentLoaded", async () => {
            initEngine();
            await loadMap();
            
            // Event listeners
            document.getElementById("searchAddress").addEventListener("click", searchAddress);
            
            // Render loop
            engine.runRenderLoop(() => scene.render());
            window.addEventListener("resize", () => engine.resize());
        });
    </script>
</body>
</html>
