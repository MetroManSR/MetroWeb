<!DOCTYPE html>
<html>
<head>
    <title>Live ASCII Terrain Map with OSM</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #121212;
            color: #e0e0e0;
            text-align: center;
            margin: 0;
            padding: 20px;
        }
        #map-container {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            margin-bottom: 20px;
            display: inline-block;
            position: relative;
        }
        #map {
            font-size: 6px;
            line-height: 6px;
            letter-spacing: 0.5px;
            white-space: pre;
            overflow: auto;
            max-height: 600px;
            max-width: 900px;
            padding: 10px;
            background: #222;
            border-radius: 4px;
            cursor: crosshair;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
            max-width: 300px;
            margin-left: auto;
            margin-right: auto;
        }
        button {
            background: #333;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            transition: background 0.2s;
        }
        button:hover {
            background: #444;
        }
        #coords, #location-info, #elevation-info {
            font-family: monospace;
            background: #252525;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 10px;
            display: inline-block;
        }
        /* Terrain Colors */
        .water { color: #5af; }
        .ground { color: #ba9; }
        .building { color: #f88; }
        .road { color: #fd5; }
        .major-road { color: #fa0; }
        .park { color: #5c5; }
        .forest { color: #3a5; }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 100;
            font-size: 12px;
            white-space: nowrap;
        }
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #fff;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <h1>Live ASCII Terrain Map with OSM</h1>
    
    <div id="coords">Latitude: 40.7128, Longitude: -74.0060</div>
    <div id="location-info">New York, US</div>
    <div id="elevation-info">Click on the map to see details</div>
    
    <div class="controls">
        <div></div>
        <button id="moveNorth">↑</button>
        <div></div>
        <button id="moveWest">←</button>
        <button id="recenter">◎</button>
        <button id="moveEast">→</button>
        <div></div>
        <button id="moveSouth">↓</button>
        <div></div>
    </div>
    
    <div id="map-container">
        <div id="map" class="loading">
            <div class="loading-spinner"></div>
            <div>Loading terrain data...</div>
        </div>
        <div class="tooltip" id="tooltip" style="display: none;"></div>
    </div>

    <script>
        // ================ CONFIGURATION ================
        const MAP_SIZE = 100; // 100x100 grid
        const CELL_SIZE_METERS = 100; // 100m per cell
        const MOVE_DISTANCE = 0.009; // ~1km movement
        const LOAD_CHUNK_SIZE = 20; // Load 20x20 cells at a time
        const ELEVATION_API_URL = 'https://api.open-elevation.com/api/v1/lookup';
        const OSM_API_URL = 'https://overpass-api.de/api/interpreter';
        
        // ================ STATE MANAGEMENT ================
        let currentLat = 40.7128; // New York
        let currentLon = -74.0060;
        let isLoading = false;
        let elevationData = Array(MAP_SIZE).fill().map(() => Array(MAP_SIZE).fill(0));
        let osmFeatures = [];
        let renderedMap = Array(MAP_SIZE).fill().map(() => Array(MAP_SIZE).fill(' '));

        // ================ ELEVATION DATA ================
        async function fetchElevationData() {
            isLoading = true;
            document.getElementById('map').className = 'loading';
            
            try {
                // Calculate the bounds of our map area
                const metersPerDegreeLat = 111320;
                const metersPerDegreeLon = 111320 * Math.cos(currentLat * Math.PI/180);
                
                // First fetch OSM data for the area
                await fetchOSMData();
                
                // Prepare elevation points to fetch
                const locations = [];
                for (let y = 0; y < MAP_SIZE; y++) {
                    for (let x = 0; x < MAP_SIZE; x++) {
                        const lat = currentLat + (y - MAP_SIZE/2) * (CELL_SIZE_METERS / metersPerDegreeLat);
                        const lon = currentLon + (x - MAP_SIZE/2) * (CELL_SIZE_METERS / metersPerDegreeLon);
                        locations.push({ latitude: lat, longitude: lon, x, y });
                    }
                }
                
                // Fetch elevation in batches
                for (let i = 0; i < locations.length; i += 100) {
                    const batch = locations.slice(i, i + 100);
                    const elevations = await getElevations(batch);
                    
                    // Store elevations
                    elevations.forEach((elev, index) => {
                        const {x, y} = batch[index];
                        elevationData[y][x] = elev;
                    });
                    
                    // Render progress
                    if (i % 500 === 0) {
                        renderMap();
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }
                
                // Final render with all data
                renderMap();
                updateStatus("Map ready");
            } catch (error) {
                console.error("Error loading map:", error);
                updateStatus("Error loading map");
            } finally {
                isLoading = false;
            }
        }

        async function getElevations(locations) {
            try {
                const response = await fetch(ELEVATION_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        locations: locations.map(loc => ({ 
                            latitude: loc.latitude, 
                            longitude: loc.longitude 
                        }))
                    })
                });
                
                if (!response.ok) throw new Error("Elevation API failed");
                const data = await response.json();
                return data.results.map(r => r.elevation);
            } catch (e) {
                console.error("Using fallback elevation data:", e);
                // Fallback to random elevations if API fails
                return locations.map(() => Math.random() * 100);
            }
        }

        // ================ OSM DATA ================
        async function fetchOSMData() {
            try {
                const radius = 0.045; // ~5km radius
                const bbox = `${currentLon - radius},${currentLat - radius},${currentLon + radius},${currentLat + radius}`;
                
                const query = `
                    [out:json];
                    (
                        way[building](${bbox});
                        way[highway](${bbox});
                        way[landuse=forest](${bbox});
                        way[leisure=park](${bbox});
                        way[natural=water](${bbox});
                    );
                    out geom;
                `;
                
                const response = await fetch(`${OSM_API_URL}?data=${encodeURIComponent(query)}`);
                if (!response.ok) throw new Error("Failed to fetch OSM data");
                osmFeatures = (await response.json()).elements;
            } catch (e) {
                console.error("Error fetching OSM data:", e);
                osmFeatures = [];
            }
        }

        // ================ RENDERING ================
        function renderMap() {
            let mapOutput = '';
            const centerElev = elevationData[Math.floor(MAP_SIZE/2)][Math.floor(MAP_SIZE/2)];
            
            // Convert OSM features to grid coordinates
            const osmGrid = createOSMFeatureGrid();
            
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const elev = elevationData[y][x];
                    
                    // Check OSM features first
                    if (osmGrid[y] && osmGrid[y][x]) {
                        const feature = osmGrid[y][x];
                        if (feature.type === 'water') {
                            mapOutput += `<span class="water">≈</span>`;
                        } else if (feature.type === 'road') {
                            mapOutput += `<span class="road">·</span>`;
                        } else if (feature.type === 'major-road') {
                            mapOutput += `<span class="major-road">#</span>`;
                        } else if (feature.type === 'building') {
                            mapOutput += `<span class="building">█</span>`;
                        } else if (feature.type === 'park') {
                            mapOutput += `<span class="park">♣</span>`;
                        } else if (feature.type === 'forest') {
                            mapOutput += `<span class="forest">♠</span>`;
                        } else {
                            mapOutput += getElevationCell(elev, centerElev, x, y);
                        }
                    } else {
                        mapOutput += getElevationCell(elev, centerElev, x, y);
                    }
                }
                mapOutput += '\n';
            }
            
            document.getElementById('map').innerHTML = mapOutput;
            document.getElementById('map').className = '';
        }

        function getElevationCell(elev, centerElev, x, y) {
            const relElev = elev - centerElev;
            
            if (elev < 10) {
                return `<span class="water" data-x="${x}" data-y="${y}">≈</span>`;
            } else if (Math.abs(relElev) < 5) {
                return `<span class="ground" data-x="${x}" data-y="${y}">·</span>`;
            } else if (relElev > 20) {
                return `<span class="building" data-x="${x}" data-y="${y}">▲</span>`;
            } else if (relElev < -5) {
                return `<span class="water" data-x="${x}" data-y="${y}">≈</span>`;
            } else {
                return `<span class="ground" data-x="${x}" data-y="${y}">·</span>`;
            }
        }

        function createOSMFeatureGrid() {
            const grid = Array(MAP_SIZE).fill().map(() => Array(MAP_SIZE).fill(null));
            const metersPerDegreeLat = 111320;
            const metersPerDegreeLon = 111320 * Math.cos(currentLat * Math.PI/180);
            
            osmFeatures.forEach(feature => {
                if (!feature.geometry) return;
                
                const coords = feature.geometry.map(coord => ({
                    x: MAP_SIZE/2 + (coord.lon - currentLon) * metersPerDegreeLon / CELL_SIZE_METERS,
                    y: MAP_SIZE/2 - (coord.lat - currentLat) * metersPerDegreeLat / CELL_SIZE_METERS
                }));
                
                if (feature.tags?.building) {
                    drawPolygonOnGrid(grid, coords, { type: 'building' });
                } else if (feature.tags?.highway) {
                    const isMajor = ['motorway', 'trunk', 'primary'].includes(feature.tags.highway);
                    drawLineOnGrid(grid, coords, { type: isMajor ? 'major-road' : 'road' });
                } else if (feature.tags?.natural === 'water') {
                    drawPolygonOnGrid(grid, coords, { type: 'water' });
                } else if (feature.tags?.leisure === 'park' || feature.tags?.landuse === 'grass') {
                    drawPolygonOnGrid(grid, coords, { type: 'park' });
                } else if (feature.tags?.natural === 'wood' || feature.tags?.landuse === 'forest') {
                    drawPolygonOnGrid(grid, coords, { type: 'forest' });
                }
            });
            
            return grid;
        }

        function drawLineOnGrid(grid, coords, feature) {
            for (let i = 0; i < coords.length - 1; i++) {
                const from = coords[i];
                const to = coords[i + 1];
                drawBresenhamLine(grid, from, to, feature);
            }
        }

        function drawPolygonOnGrid(grid, coords, feature) {
            if (coords.length < 3) return;
            
            // Draw outline
            drawLineOnGrid(grid, coords, feature);
            
            // Fill polygon
            const minY = Math.max(0, Math.floor(Math.min(...coords.map(c => c.y))));
            const maxY = Math.min(MAP_SIZE-1, Math.ceil(Math.max(...coords.map(c => c.y))));
            
            for (let y = minY; y <= maxY; y++) {
                const intersections = [];
                for (let i = 0; i < coords.length; i++) {
                    const from = coords[i];
                    const to = coords[(i + 1) % coords.length];
                    
                    if ((from.y <= y && to.y > y) || (to.y <= y && from.y > y)) {
                        const x = from.x + (to.x - from.x) * (y - from.y) / (to.y - from.y);
                        intersections.push(x);
                    }
                }
                
                intersections.sort((a, b) => a - b);
                for (let i = 0; i < intersections.length; i += 2) {
                    const startX = Math.max(0, Math.floor(intersections[i]));
                    const endX = Math.min(MAP_SIZE-1, Math.ceil(intersections[i + 1] || intersections[i]));
                    
                    for (let x = startX; x <= endX; x++) {
                        if (!grid[y][x]) {
                            grid[y][x] = feature;
                        }
                    }
                }
            }
        }

        function drawBresenhamLine(grid, from, to, feature) {
            let x0 = Math.round(from.x);
            let y0 = Math.round(from.y);
            const x1 = Math.round(to.x);
            const y1 = Math.round(to.y);
            
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = (x0 < x1) ? 1 : -1;
            const sy = (y0 < y1) ? 1 : -1;
            let err = dx - dy;
            
            while (true) {
                if (y0 >= 0 && y0 < MAP_SIZE && x0 >= 0 && x0 < MAP_SIZE) {
                    if (!grid[y0][x0] || grid[y0][x0].type !== 'road') {
                        grid[y0][x0] = feature;
                    }
                }
                
                if (x0 === x1 && y0 === y1) break;
                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }
            }
        }

        // ================ INTERACTIVITY ================
        function setupMapClickHandler() {
            const mapElement = document.getElementById('map');
            const tooltip = document.getElementById('tooltip');
            
            mapElement.addEventListener('click', (e) => {
                let target = e.target;
                while (target && !target.hasAttribute('data-x')) {
                    target = target.parentElement;
                    if (target === mapElement) return;
                }
                
                if (target && target.hasAttribute('data-x')) {
                    const x = parseInt(target.getAttribute('data-x'));
                    const y = parseInt(target.getAttribute('data-y'));
                    const elev = elevationData[y][x];
                    
                    const metersPerDegreeLat = 111320;
                    const metersPerDegreeLon = 111320 * Math.cos(currentLat * Math.PI/180);
                    const lat = currentLat + (y - MAP_SIZE/2) * (CELL_SIZE_METERS / metersPerDegreeLat);
                    const lon = currentLon + (x - MAP_SIZE/2) * (CELL_SIZE_METERS / metersPerDegreeLon);
                    
                    let featureInfo = "";
                    const osmGrid = createOSMFeatureGrid();
                    if (osmGrid[y] && osmGrid[y][x]) {
                        const feature = osmGrid[y][x];
                        featureInfo = ` (${feature.type})`;
                    }
                    
                    document.getElementById('elevation-info').textContent = 
                        `Elevation: ${elev.toFixed(1)}m${featureInfo} | Coordinates: ${lat.toFixed(6)}, ${lon.toFixed(6)}`;
                }
            });
            
            mapElement.addEventListener('mousemove', (e) => {
                let target = e.target;
                while (target && !target.hasAttribute('data-x')) {
                    target = target.parentElement;
                    if (target === mapElement) return;
                }
                
                if (target && target.hasAttribute('data-x')) {
                    const x = parseInt(target.getAttribute('data-x'));
                    const y = parseInt(target.getAttribute('data-y'));
                    const elev = elevationData[y][x];
                    
                    let featureInfo = "";
                    const osmGrid = createOSMFeatureGrid();
                    if (osmGrid[y] && osmGrid[y][x]) {
                        const feature = osmGrid[y][x];
                        featureInfo = ` (${feature.type})`;
                    }
                    
                    tooltip.style.display = 'block';
                    tooltip.textContent = `${elev.toFixed(1)}m${featureInfo}`;
                    tooltip.style.left = `${e.clientX + 10}px`;
                    tooltip.style.top = `${e.clientY + 10}px`;
                } else {
                    tooltip.style.display = 'none';
                }
            });
            
            mapElement.addEventListener('mouseout', () => {
                tooltip.style.display = 'none';
            });
        }

        // ================ NAVIGATION ================
        function moveMap(dLat, dLon) {
            if (isLoading) return;
            
            currentLat = +(currentLat + dLat).toFixed(6);
            currentLon = +(currentLon + dLon).toFixed(6);
            
            updateCoords();
            fetchElevationData();
        }

        function recenter() {
            currentLat = 40.7128;
            currentLon = -74.0060;
            updateCoords();
            fetchElevationData();
        }

        // ================ UTILITY FUNCTIONS ================
        function updateCoords() {
            document.getElementById('coords').textContent = 
                `Latitude: ${currentLat.toFixed(4)}, Longitude: ${currentLon.toFixed(4)}`;
        }

        function updateStatus(msg) {
            console.log(msg);
        }

        // ================ INITIALIZATION ================
        document.getElementById('moveNorth').addEventListener('click', () => moveMap(-MOVE_DISTANCE, 0));
        document.getElementById('moveSouth').addEventListener('click', () => moveMap(MOVE_DISTANCE, 0));
        document.getElementById('moveWest').addEventListener('click', () => moveMap(0, -MOVE_DISTANCE));
        document.getElementById('moveEast').addEventListener('click', () => moveMap(0, MOVE_DISTANCE));
        document.getElementById('recenter').addEventListener('click', recenter);

        setupMapClickHandler();
        fetchElevationData();
    </script>
</body>
</html>
