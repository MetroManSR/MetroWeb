<!DOCTYPE html>
<html>
<head>
    <title>3D Terrain Map with Babylon.js</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
        #controls {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.7); padding: 10px; color: white;
            border-radius: 5px;
        }
        button { margin: 5px; }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
    <div id="controls">
        <input type="text" id="addressInput" placeholder="Search address">
        <button id="searchAddress">Search</button>
        <div>Coordinates: <span id="coords">-33.4550, -70.6600</span></div>
    </div>
    <canvas id="renderCanvas"></canvas>

    <script>
        // ================ INITIALIZE BABYLON ================
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.2, 1);

        // Camera
        const camera = new BABYLON.ArcRotateCamera(
            "camera", 
            -Math.PI / 2, Math.PI / 4, 50, 
            new BABYLON.Vector3(0, 0, 0), 
            scene
        );
        camera.attachControl(canvas, true);
        camera.upperBetaLimit = Math.PI / 2.2; // Prevent flipping
        camera.lowerRadiusLimit = 10;
        camera.upperRadiusLimit = 200;

        // Light
        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
        light.intensity = 0.8;

        // ================ TERRAIN GENERATION ================
        function createTerrain(elevationData) {
            const size = 100; // Grid size
            const terrain = new BABYLON.MeshBuilder.CreateGround(
                "terrain", 
                { width: size, height: size, subdivisions: size - 1 }, 
                scene
            );

            // Apply elevation (heightmap)
            const vertexData = BABYLON.VertexData.ExtractFromMesh(terrain);
            for (let i = 0; i < vertexData.positions.length; i += 3) {
                const x = Math.round(vertexData.positions[i] + size/2);
                const z = Math.round(vertexData.positions[i+2] + size/2);
                vertexData.positions[i+1] = elevationData[z][x] / 50; // Scale down height
            }
            vertexData.applyToMesh(terrain);

            // Material (color by elevation)
            const terrainMat = new BABYLON.StandardMaterial("terrainMat", scene);
            terrainMat.diffuseColor = new BABYLON.Color3(0.4, 0.6, 0.3);
            terrain.material = terrainMat;
            return terrain;
        }

        // ================ OSM FEATURES ================
        function createRoad(points, width = 0.3, isMajor = false) {
            const road = BABYLON.MeshBuilder.CreateRibbon("road", {
                pathArray: points.map(p => new BABYLON.Vector3(p.x - 50, 0.1, p.y - 50)),
                closeArray: false,
                sideOrientation: BABYLON.Mesh.DOUBLESIDE
            }, scene);
            road.scaling.y = width;
            const mat = new BABYLON.StandardMaterial("roadMat", scene);
            mat.diffuseColor = isMajor ? new BABYLON.Color3(1, 0.6, 0) : new BABYLON.Color3(1, 0.8, 0.3);
            road.material = mat;
        }

        function createBuilding(x, y, width, height, depth = 2) {
            const building = BABYLON.MeshBuilder.CreateBox("building", {
                width, height: depth, depth: height
            }, scene);
            building.position = new BABYLON.Vector3(x - 50, depth/2, y - 50);
            const mat = new BABYLON.StandardMaterial("buildingMat", scene);
            mat.diffuseColor = new BABYLON.Color3(0.9, 0.3, 0.3);
            building.material = mat;
        }

        // ================ MOCK DATA (REPLACE WITH REAL API CALLS) ================
        function generateMockData() {
            // Elevation data (simulated)
            const elevationData = [];
            for (let z = 0; z < 100; z++) {
                elevationData[z] = [];
                for (let x = 0; x < 100; x++) {
                    elevationData[z][x] = 20 * Math.sin(x/10) * Math.cos(z/10) + 30;
                }
            }

            // OSM features (simulated)
            const roads = [
                { points: [{x: 10, y: 50}, {x: 90, y: 50}], isMajor: true },
                { points: [{x: 50, y: 10}, {x: 50, y: 90}], isMajor: true }
            ];
            const buildings = [
                { x: 35, y: 35, w: 5, h: 8 },
                { x: 60, y: 60, w: 6, h: 6 }
            ];

            return { elevationData, roads, buildings };
        }

        // ================ LOAD AND RENDER ================
        function loadMap() {
            scene.dispose();
            const { elevationData, roads, buildings } = generateMockData();
            
            // Create terrain
            createTerrain(elevationData);

            // Add roads
            roads.forEach(road => createRoad(road.points, 0.5, road.isMajor));

            // Add buildings
            buildings.forEach(b => createBuilding(b.x, b.y, b.w, b.h));
        }

        // ================ NAVIGATION ================
        function moveMap(dLat, dLon) {
            // In a real app, fetch new terrain data for these coordinates
            console.log(`Moving to ${dLat}, ${dLon}`);
            updateCoords();
        }

        function updateCoords() {
            document.getElementById('coords').textContent = 
                `${currentLat.toFixed(5)}, ${currentLon.toFixed(5)}`;
        }

        // ================ INITIALIZE ================
        let currentLat = -33.4550;
        let currentLon = -70.6600;

        // UI Events
        document.getElementById('searchAddress').addEventListener('click', () => {
            alert("In a real app, this would geocode the address and update the map.");
        });

        // First load
        loadMap();

        // Run the engine
        engine.runRenderLoop(() => scene.render());
        window.addEventListener('resize', () => engine.resize());
    </script>
</body>
</html>
