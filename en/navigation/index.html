<!DOCTYPE html>
<html>
<head>
    <title>3D Terrain with Real OSM Data</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
        #controls {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.7); padding: 10px; color: white;
            border-radius: 5px; z-index: 10;
        }
        button { margin: 5px; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
    <div id="controls">
        <input type="text" id="addressInput" placeholder="Search address">
        <button id="searchAddress">Search</button>
        <div>Coordinates: <span id="coords">-33.4550, -70.6600</span></div>
    </div>
    <div id="loading">Loading...</div>
    <canvas id="renderCanvas"></canvas>

    <script>
        // ================ GLOBALS ================
        let scene;
        let engine;
        let currentLat = -33.4550;
        let currentLon = -70.6600;
        const TERRAIN_SIZE = 1000; // Meters

        // ================ INIT BABYLON ================
        const initEngine = () => {
            const canvas = document.getElementById("renderCanvas");
            engine = new BABYLON.Engine(canvas, true);
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.2, 1);

            // Camera
            const camera = new BABYLON.ArcRotateCamera(
                "camera", 
                -Math.PI / 2, Math.PI / 4, 500, 
                new BABYLON.Vector3(0, 0, 0), 
                scene
            );
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 100;
            camera.upperRadiusLimit = 2000;

            // Light
            new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene).intensity = 0.8;

            return { scene, engine, camera };
        };

        // ================ REAL ELEVATION DATA ================
        const fetchRealElevation = async (lat, lon) => {
            try {
                const response = await fetch(
                    `https://api.opentopodata.org/v1/ned?locations=${lat},${lon}`
                );
                const data = await response.json();
                return data.results[0].elevation;
            } catch (error) {
                console.error("Elevation API Error:", error);
                return 0;
            }
        };

        // ================ TERRAIN GENERATION ================
        const createTerrain = async (lat, lon) => {
            const subdivisions = 100;
            const baseElevation = await fetchRealElevation(lat, lon);
            
            const terrain = BABYLON.MeshBuilder.CreateGround(
                "terrain",
                {
                    width: TERRAIN_SIZE,
                    height: TERRAIN_SIZE,
                    subdivisions,
                    updatable: true
                },
                scene
            );

            // Apply elevation
            const positions = terrain.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            for (let i = 2; i < positions.length; i += 3) {
                positions[i] = baseElevation + (Math.random() * 20); // Add minor variation
            }
            terrain.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);

            // Material
            const terrainMat = new BABYLON.StandardMaterial("terrainMat", scene);
            terrainMat.diffuseColor = new BABYLON.Color3(0.4, 0.6, 0.3);
            terrain.material = terrainMat;
        };

        // ================ OSM RENDERING ================
        const fetchOSMData = async (lat, lon, radius = 500) => {
            const overpassUrl = `https://overpass-api.de/api/interpreter?data=
                [out:json];
                (
                    way[~"highway"~"motorway|trunk|primary|secondary|tertiary|residential"]
                    (around:${radius},${lat},${lon});
                    way["building"](around:${radius},${lat},${lon});
                out geom;`;

            try {
                const response = await fetch(overpassUrl);
                return await response.json();
            } catch (error) {
                console.error("OSM Error:", error);
                return { elements: [] };
            }
        };

        const renderOSMFeatures = (elements) => {
            elements.forEach(element => {
                if (element.tags?.highway) {
                    createRoad(element.geometry, element.tags.highway.includes("motorway"));
                } else if (element.tags?.building) {
                    createBuilding(element.geometry);
                }
            });
        };

        const createRoad = (geometry, isMajor) => {
            const points = geometry.map(pt => 
                new BABYLON.Vector3(
                    (pt.lon - currentLon) * 111320, 
                    0.5, 
                    -(pt.lat - currentLat) * 111320
                )
            );

            BABYLON.MeshBuilder.CreateTube("road", {
                path: points,
                radius: isMajor ? 5 : 3,
                tessellation: 4
            }, scene).material = new BABYLON.StandardMaterial("roadMat", scene)
                .diffuseColor = isMajor ? new BABYLON.Color3(0.9, 0.5, 0) : new BABYLON.Color3(0.8, 0.8, 0.6);
        };

        const createBuilding = (geometry) => {
            const baseHeight = 10 + Math.random() * 20;
            const polygon = geometry.map(pt => 
                new BABYLON.Vector3(
                    (pt.lon - currentLon) * 111320, 
                    0, 
                    -(pt.lat - currentLat) * 111320
                )
            );

            BABYLON.MeshBuilder.ExtrudePolygon("building", {
                shape: polygon,
                depth: baseHeight
            }, scene).material = new BABYLON.StandardMaterial("buildingMat", scene)
                .diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7);
        };

        // ================ MAIN LOGIC ================
        const loadMap = async () => {
            document.getElementById("loading").style.display = "block";
            
            try {
                // Clear previous scene
                scene.getMeshes().forEach(mesh => mesh.dispose());
                
                // Create new terrain
                await createTerrain(currentLat, currentLon);

                // Fetch and render OSM
                const osmData = await fetchOSMData(currentLat, currentLon);
                renderOSMFeatures(osmData.elements);

                updateCoords();
            } catch (error) {
                console.error("Load error:", error);
            } finally {
                document.getElementById("loading").style.display = "none";
            }
        };

        // ================ UI CONTROLS ================
        const updateCoords = () => {
            document.getElementById("coords").textContent = 
                `${currentLat.toFixed(5)}, ${currentLon.toFixed(5)}`;
        };

        const searchAddress = async () => {
            const address = document.getElementById("addressInput").value;
            if (!address) return;
            
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`
                );
                const data = await response.json();
                if (data.length > 0) {
                    currentLat = parseFloat(data[0].lat);
                    currentLon = parseFloat(data[0].lon);
                    await loadMap();
                }
            } catch (error) {
                console.error("Geocoding error:", error);
            }
        };

        // ================ INIT ================
        window.addEventListener("DOMContentLoaded", async () => {
            initEngine();
            await loadMap();
            
            document.getElementById("searchAddress").addEventListener("click", searchAddress);
            engine.runRenderLoop(() => scene.render());
            window.addEventListener("resize", () => engine.resize());
        });
    </script>
</body>
</html>
