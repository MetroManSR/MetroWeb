<!DOCTYPE html>
<html>
<head>
    <title>Smart City Terrain Map</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #121212;
            color: #e0e0e0;
            text-align: center;
            margin: 0;
            padding: 20px;
        }
        #map-container {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            margin-bottom: 20px;
            display: inline-block;
        }
        #map {
            font-size: 8px;
            line-height: 8px;
            letter-spacing: 1px;
            white-space: pre;
            overflow: auto;
            max-height: 500px;
            padding: 10px;
            background: #222;
            border-radius: 4px;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
            max-width: 300px;
            margin-left: auto;
            margin-right: auto;
        }
        button {
            background: #333;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            transition: background 0.2s;
        }
        button:hover {
            background: #444;
        }
        button:active {
            background: #555;
        }
        .nav-btn {
            font-size: 16px;
            padding: 10px;
        }
        #coords, #location-info {
            font-family: monospace;
            background: #252525;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 10px;
            display: inline-block;
        }
        #status {
            color: #aaa;
            font-size: 14px;
            margin-top: 10px;
        }
        /* Terrain Colors */
        .water { color: #5af; }
        .ground { color: #ba9; }
        .building { color: #f88; }
        .road { color: #fd5; }
        .park { color: #5c5; }
        .lidar { color: #8cf; }
        .unknown { color: #777; }
    </style>
</head>
<body>
    <h1>Smart City Terrain Map</h1>
    
    <div id="coords">Latitude: 40.7128, Longitude: -74.0060</div>
    <div id="location-info">New York, US | Using: USGS LIDAR</div>
    
    <div class="controls">
        <div></div>
        <button class="nav-btn" id="moveNorth">↑</button>
        <div></div>
        <button class="nav-btn" id="moveWest">←</button>
        <button id="recenter">◎</button>
        <button class="nav-btn" id="moveEast">→</button>
        <div></div>
        <button class="nav-btn" id="moveSouth">↓</button>
        <div></div>
    </div>
    
    <div id="map-container">
        <div id="map" class="loading">Initializing urban terrain engine...</div>
    </div>
    
    <div id="status">Detecting best elevation source...</div>

    <script>
        // ================ CONFIGURATION ================
        const MAP_SIZE = 50; // 50x50 characters
        const CELL_SIZE_METERS = 10; // 10m per character
        const MOVE_DISTANCE = 0.001; // Degrees per movement (~100m)
        const SMOOTHING_RADIUS = 3; // Cells to smooth across borders
        
        // ================ STATE MANAGEMENT ================
        let currentLat = 40.7128; // New York
        let currentLon = -74.0060;
        let isLoading = false;
        let currentCountry = null;
        let currentDataSource = null;
        let elevationCache = new Map();

        // ================ DATA SOURCE REGISTRY ================
        const DATA_SOURCES = {
            // North America (US/Canada)
            'NA': {
                name: "USGS 3DEP LIDAR",
                resolution: 1, // 1m
                getElevation: async (lat, lon) => {
                    // USGS 3DEP API endpoint
                    try {
                        const response = await fetch(`https://elevation.nationalmap.gov/arcgis/rest/services/3DEPElevation/ImageServer/getSamples?geometry=${lon},${lat}&geometryType=esriGeometryPoint&returnFirstValueOnly=true&f=json`);
                        const data = await response.json();
                        return data.value;
                    } catch (e) {
                        console.warn("LIDAR failed, falling back to SRTM");
                        return getSRTMElevation(lat, lon);
                    }
                }
            },
            
            // Europe
            'EU': {
                name: "EU-DEM LIDAR",
                resolution: 5, // 5m
                getElevation: async (lat, lon) => {
                    // EU-DEM API endpoint
                    try {
                        const response = await fetch(`https://portal.opentopography.org/API/globaldem?demtype=EU_DTM&south=${lat-0.001}&north=${lat+0.001}&west=${lon-0.001}&east=${lon+0.001}&outputFormat=JSON`);
                        const data = await response.json();
                        return data.data[0].elevation;
                    } catch (e) {
                        console.warn("EU-DEM failed, falling back to SRTM");
                        return getSRTMElevation(lat, lon);
                    }
                }
            },
            
            // Global fallback
            'GLOBAL': {
                name: "SRTM",
                resolution: 30, // 30m
                getElevation: getSRTMElevation
            }
        };

        // ================ COUNTRY DETECTION ================
        async function detectCountry(lat, lon) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`);
                const data = await response.json();
                const countryCode = data.address?.country_code?.toUpperCase();
                
                // Determine which data source to use based on country
                if (['US', 'CA'].includes(countryCode)) return 'NA';
                if (['DE', 'FR', 'UK', 'ES', 'IT'].includes(countryCode)) return 'EU';
                return 'GLOBAL';
            } catch (e) {
                console.warn("Country detection failed, using global data");
                return 'GLOBAL';
            }
        }

        // ================ ELEVATION FUNCTIONS ================
        async function getSRTMElevation(lat, lon) {
            // Simple SRTM implementation (would use AWS tiles in production)
            try {
                const response = await fetch(`https://api.opentopodata.org/v1/srtm30m?locations=${lat},${lon}`);
                const data = await response.json();
                return data.results[0].elevation;
            } catch (e) {
                console.warn("SRTM failed, using fallback elevation");
                return Math.random() * 1000; // Fallback
            }
        }

        async function getElevation(lat, lon) {
            const cacheKey = `${lat.toFixed(5)},${lon.toFixed(5)}`;
            
            // Check cache first
            if (elevationCache.has(cacheKey)) {
                return elevationCache.get(cacheKey);
            }
            
            // Get elevation from appropriate source
            const elevation = await currentDataSource.getElevation(lat, lon);
            
            // Cache the result
            elevationCache.set(cacheKey, elevation);
            return elevation;
        }

        // ================ TERRAIN GENERATION ================
        async function generateMap() {
            if (isLoading) return;
            isLoading = true;
            
            // Detect country and select data source
            currentCountry = await detectCountry(currentLat, currentLon);
            currentDataSource = DATA_SOURCES[currentCountry];
            
            updateStatus(`Loading ${currentDataSource.name} data...`);
            updateCoords();
            updateLocationInfo();
            
            document.getElementById('map').className = 'loading';
            document.getElementById('map').textContent = 'Rendering city terrain...';
            
            try {
                // Generate base grid
                const grid = await generateElevationGrid();
                
                // Apply smoothing near borders if needed
                await applyBorderSmoothing(grid);
                
                // Render the final map
                renderMap(grid);
                
                updateStatus("City terrain ready");
            } catch (error) {
                console.error("Map generation failed:", error);
                document.getElementById('map').textContent = "Error: Could not load terrain data";
                updateStatus("Failed to generate map");
            } finally {
                isLoading = false;
            }
        }

        async function generateElevationGrid() {
            const grid = [];
            const startTime = performance.now();
            
            // Calculate grid bounds in meters
            const metersPerDegreeLat = 111320;
            const metersPerDegreeLon = 111320 * Math.cos(currentLat * Math.PI/180);
            
            for (let y = 0; y < MAP_SIZE; y++) {
                grid[y] = [];
                for (let x = 0; x < MAP_SIZE; x++) {
                    // Calculate lat/lon for this cell
                    const lat = currentLat + (y - MAP_SIZE/2) * (CELL_SIZE_METERS / metersPerDegreeLat);
                    const lon = currentLon + (x - MAP_SIZE/2) * (CELL_SIZE_METERS / metersPerDegreeLon);
                    
                    // Get elevation with caching
                    grid[y][x] = await getElevation(lat, lon);
                    
                    // Update progress
                    if ((y * MAP_SIZE + x) % 100 === 0) {
                        updateStatus(`Loading terrain... ${Math.round((y * MAP_SIZE + x) / (MAP_SIZE * MAP_SIZE) * 100)}%`);
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }
            }
            
            console.log(`Grid generated in ${performance.now() - startTime}ms`);
            return grid;
        }

        async function applyBorderSmoothing(grid) {
            // This would detect borders between data sources and smooth them
            // In a real implementation, we'd compare adjacent cells' data sources
            // and apply smoothing filters at transitions
            
            // For now, just apply mild smoothing to all data
            const smoothedGrid = JSON.parse(JSON.stringify(grid));
            
            for (let y = SMOOTHING_RADIUS; y < MAP_SIZE - SMOOTHING_RADIUS; y++) {
                for (let x = SMOOTHING_RADIUS; x < MAP_SIZE - SMOOTHING_RADIUS; x++) {
                    let sum = 0;
                    let count = 0;
                    
                    for (let dy = -SMOOTHING_RADIUS; dy <= SMOOTHING_RADIUS; dy++) {
                        for (let dx = -SMOOTHING_RADIUS; dx <= SMOOTHING_RADIUS; dx++) {
                            sum += grid[y+dy][x+dx];
                            count++;
                        }
                    }
                    
                    smoothedGrid[y][x] = sum / count;
                }
            }
            
            return smoothedGrid;
        }

        function renderMap(grid) {
            let mapOutput = '';
            
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const elev = grid[y][x];
                    let char, cls;
                    
                    // Simple urban terrain classification
                    if (elev < 10) {
                        char = '≈'; cls = 'water';
                    } else if (elev > 100 && elev < 150) {
                        char = '═'; cls = 'road';
                    } else if (elev > 150) {
                        char = '█'; cls = 'building';
                    } else {
                        // Use different style for LIDAR data
                        char = '·'; 
                        cls = currentDataSource.resolution <= 5 ? 'lidar' : 'ground';
                    }
                    
                    mapOutput += `<span class="${cls}">${char}</span>`;
                }
                mapOutput += '\n';
            }
            
            document.getElementById('map').innerHTML = mapOutput;
            document.getElementById('map').className = '';
        }

        // ================ UTILITIES ================
        function moveMap(dLat, dLon) {
            currentLat = +(currentLat + dLat).toFixed(6);
            currentLon = +(currentLon + dLon).toFixed(6);
            
            // Clear cache when moving significantly
            if (Math.abs(dLat) > 0.01 || Math.abs(dLon) > 0.01) {
                elevationCache.clear();
            }
            
            generateMap();
        }

        function updateCoords() {
            document.getElementById('coords').textContent = 
                `Latitude: ${currentLat.toFixed(4)}, Longitude: ${currentLon.toFixed(4)}`;
        }

        async function updateLocationInfo() {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${currentLat}&lon=${currentLon}`);
                const data = await response.json();
                const city = data.address?.city || data.address?.town || "Unknown";
                const country = data.address?.country || "Unknown";
                
                document.getElementById('location-info').textContent = 
                    `${city}, ${country} | Using: ${currentDataSource.name}`;
            } catch (e) {
                document.getElementById('location-info').textContent = 
                    `Using: ${currentDataSource.name}`;
            }
        }

        function updateStatus(msg) {
            document.getElementById('status').textContent = msg;
        }

        function recenter() {
            currentLat = 40.7128;
            currentLon = -74.0060;
            elevationCache.clear();
            generateMap();
        }

        // ================ INITIALIZATION ================
        document.getElementById('moveNorth').addEventListener('click', () => moveMap(-MOVE_DISTANCE, 0));
        document.getElementById('moveSouth').addEventListener('click', () => moveMap(MOVE_DISTANCE, 0));
        document.getElementById('moveWest').addEventListener('click', () => moveMap(0, -MOVE_DISTANCE));
        document.getElementById('moveEast').addEventListener('click', () => moveMap(0, MOVE_DISTANCE));
        document.getElementById('recenter').addEventListener('click', recenter);

        // Start loading
        generateMap();
    </script>
</body>
</html>
