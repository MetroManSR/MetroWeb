<!DOCTYPE html>
<html>
<head>
    <title>10km Interactive Terrain Map with OSM</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #121212;
            color: #e0e0e0;
            text-align: center;
            margin: 0;
            padding: 20px;
        }
        #map-container {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            margin-bottom: 20px;
            display: inline-block;
            position: relative;
        }
        #map {
            font-size: 6px;
            line-height: 6px;
            letter-spacing: 0.5px;
            white-space: pre;
            overflow: auto;
            max-height: 600px;
            max-width: 900px;
            padding: 10px;
            background: #222;
            border-radius: 4px;
            cursor: crosshair;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
            max-width: 300px;
            margin-left: auto;
            margin-right: auto;
        }
        button {
            background: #333;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            transition: background 0.2s;
        }
        button:hover {
            background: #444;
        }
        button:active {
            background: #555;
        }
        .nav-btn {
            font-size: 16px;
            padding: 10px;
        }
        #coords, #location-info, #elevation-info {
            font-family: monospace;
            background: #252525;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 10px;
            display: inline-block;
        }
        #status {
            color: #aaa;
            font-size: 14px;
            margin-top: 10px;
        }
        .coord-input {
            margin: 10px 0;
        }
        .coord-input input {
            background: #252525;
            color: white;
            border: 1px solid #333;
            padding: 8px;
            border-radius: 4px;
            width: 120px;
            margin: 0 5px;
        }
        .coord-input button {
            margin-left: 10px;
        }
        /* Terrain Colors */
        .water { color: #5af; }
        .ground { color: #ba9; }
        .building { color: #f88; }
        .road { color: #fd5; }
        .park { color: #5c5; }
        .forest { color: #3a5; }
        .lidar { color: #8cf; }
        .unknown { color: #777; }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 100;
            font-size: 12px;
            white-space: nowrap;
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #fff;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <h1>10km Interactive Terrain Map with OSM</h1>
    
    <div id="coords">Latitude: 40.7128, Longitude: -74.0060</div>
    <div id="location-info">New York, US | Using: Global Dataset</div>
    <div id="elevation-info">Click on the map to see elevation and features</div>
    
    <div class="coord-input">
        <input type="text" id="latInput" placeholder="Latitude" value="40.7128">
        <input type="text" id="lonInput" placeholder="Longitude" value="-74.0060">
        <button id="goToCoords">Go</button>
    </div>
    
    <div class="controls">
        <div></div>
        <button class="nav-btn" id="moveNorth">↑</button>
        <div></div>
        <button class="nav-btn" id="moveWest">←</button>
        <button id="recenter">◎</button>
        <button class="nav-btn" id="moveEast">→</button>
        <div></div>
        <button class="nav-btn" id="moveSouth">↓</button>
        <div></div>
    </div>
    
    <div id="map-container">
        <div id="map" class="loading">
            <div class="loading-spinner"></div>
            <div>Initializing terrain engine...</div>
        </div>
        <div class="tooltip" id="tooltip" style="display: none;"></div>
    </div>
    
    <div id="status">Detecting elevation source...</div>

    <script>
        // ================ CONFIGURATION ================
        const MAP_SIZE = 100; // 100x100 characters (10km x 10km)
        const CELL_SIZE_METERS = 100; // 100m per character (10000m/100=100m)
        const MOVE_DISTANCE = 0.009; // Degrees per movement (~1km)
        const MAX_DISTANCE = 0.045; // ~5km from center (10x10km total)
        
        // ================ STATE MANAGEMENT ================
        let currentLat = 40.7128; // New York
        let currentLon = -74.0060;
        let isLoading = false;
        let currentDataSource = { name: "Global Dataset", resolution: 90 };
        let elevationCache = new Map();
        let currentElevationGrid = null;
        let osmFeatures = [];

        // ================ ELEVATION DATA FUNCTIONS ================
        async function getElevation(lat, lon) {
            const cacheKey = `${lat.toFixed(5)},${lon.toFixed(5)}`;
            
            if (elevationCache.has(cacheKey)) {
                return elevationCache.get(cacheKey);
            }
            
            const zoom = 10;
            const latRad = lat * Math.PI / 180;
            const n = Math.pow(2, zoom);
            const tileX = Math.floor((lon + 180) / 360 * n);
            const tileY = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n);
            
            const tileCacheKey = `tile-${zoom}-${tileX}-${tileY}`;
            
            try {
                if (!elevationCache.has(tileCacheKey)) {
                    const response = await fetch(`https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${zoom}/${tileX}/${tileY}.png`);
                    if (!response.ok) throw new Error("Failed to fetch elevation tile");
                    const blob = await response.blob();
                    const img = await createImageBitmap(blob);
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    ctx.drawImage(img, 0, 0);
                    
                    elevationCache.set(tileCacheKey, canvas);
                }
                
                const canvas = elevationCache.get(tileCacheKey);
                const ctx = canvas.getContext('2d');
                
                const pixelX = Math.floor(((lon + 180) / 360 * n - tileX) * 256);
                const pixelY = Math.floor(((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n - tileY) * 256);
                
                const pixelData = ctx.getImageData(pixelX, pixelY, 1, 1).data;
                const elevation = (pixelData[0] * 256 + pixelData[1] + pixelData[2] / 256) - 32768;
                
                elevationCache.set(cacheKey, elevation);
                return elevation;
            } catch (e) {
                console.error("Error getting elevation:", e);
                elevationCache.set(cacheKey, 0); // Cache failure to prevent retries
                return 0;
            }
        }

        // ================ OSM DATA FUNCTIONS ================
        async function fetchOSMFeatures(lat, lon) {
            const radius = 0.045; // ~5km radius
            const bbox = `${lon - radius},${lat - radius},${lon + radius},${lat + radius}`;
            
            try {
                const response = await fetch(`https://overpass-api.de/api/interpreter?data=[out:xml];(node(${bbox});way(${bbox});relation(${bbox}););out;>;out skel qt;`);
                if (!response.ok) throw new Error("Failed to fetch OSM data");
                const xml = await response.text();
                return parseOSMXML(xml);
            } catch (e) {
                console.error("Error fetching OSM data:", e);
                return [];
            }
        }

        function parseOSMXML(xml) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(xml, "text/xml");
            const features = [];
            const nodeMap = new Map();
            
            // First pass: collect all nodes
            const nodes = doc.getElementsByTagName('node');
            for (const node of nodes) {
                const id = node.getAttribute('id');
                const lat = parseFloat(node.getAttribute('lat'));
                const lon = parseFloat(node.getAttribute('lon'));
                
                const tags = {};
                for (const tag of node.getElementsByTagName('tag')) {
                    tags[tag.getAttribute('k')] = tag.getAttribute('v');
                }
                
                nodeMap.set(id, { lat, lon, tags });
            }
            
            // Second pass: process ways
            const ways = doc.getElementsByTagName('way');
            for (const way of ways) {
                const id = way.getAttribute('id');
                const nodes = [];
                
                for (const nd of way.getElementsByTagName('nd')) {
                    const ref = nd.getAttribute('ref');
                    if (nodeMap.has(ref)) {
                        nodes.push(nodeMap.get(ref));
                    }
                }
                
                const tags = {};
                for (const tag of way.getElementsByTagName('tag')) {
                    tags[tag.getAttribute('k')] = tag.getAttribute('v');
                }
                
                if (nodes.length > 0) {
                    features.push({
                        type: 'way',
                        id,
                        nodes,
                        tags
                    });
                }
            }
            
            return features;
        }

        // ================ MAP RENDERING FUNCTIONS ================
        async function generateMap() {
            if (isLoading) return;
            isLoading = true;
            
            updateStatus("Loading data sources...");
            updateCoords();
            
            document.getElementById('map').className = 'loading';
            document.getElementById('map').innerHTML = `
                <div class="loading-spinner"></div>
                <div>Loading terrain and OSM data...</div>
            `;
            
            try {
                // Load elevation data
                currentElevationGrid = await generateElevationGrid();
                
                // Load OSM data
                osmFeatures = await fetchOSMFeatures(currentLat, currentLon);
                
                // Render combined map
                renderMap(currentElevationGrid);
                updateStatus(`Ready | ${currentDataSource.name} + OSM | 10x10km area`);
                updateLocationInfo();
            } catch (error) {
                console.error("Map generation failed:", error);
                document.getElementById('map').innerHTML = "Error: Could not load map data";
                updateStatus("Failed to generate map");
            } finally {
                isLoading = false;
            }
        }

        async function generateElevationGrid() {
            const grid = [];
            const metersPerDegreeLat = 111320;
            const metersPerDegreeLon = 111320 * Math.cos(currentLat * Math.PI/180);
            
            for (let y = 0; y < MAP_SIZE; y++) {
                grid[y] = [];
                for (let x = 0; x < MAP_SIZE; x++) {
                    const lat = currentLat + (y - MAP_SIZE/2) * (CELL_SIZE_METERS / metersPerDegreeLat);
                    const lon = currentLon + (x - MAP_SIZE/2) * (CELL_SIZE_METERS / metersPerDegreeLon);
                    
                    // Check bounds
                    const distLat = Math.abs(lat - currentLat) * metersPerDegreeLat;
                    const distLon = Math.abs(lon - currentLon) * metersPerDegreeLon;
                    
                    if (distLat > 5000 || distLon > 5000) {
                        grid[y][x] = 0; // Out of bounds
                        continue;
                    }
                    
                    grid[y][x] = await getElevation(lat, lon);
                    
                    // Throttle requests
                    if ((y * MAP_SIZE + x) % 10 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }
            }
            
            return grid;
        }

        function renderMap(grid) {
            let mapOutput = '';
            const centerElev = grid[Math.floor(MAP_SIZE/2)][Math.floor(MAP_SIZE/2)];
            const osmGrid = createOSMFeatureGrid();
            
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const elev = grid[y][x];
                    let char, cls;
                    
                    if (elev === 0) {
                        mapOutput += ' ';
                        continue;
                    }
                    
                    // Check OSM features first
                    if (osmGrid[y] && osmGrid[y][x]) {
                        const feature = osmGrid[y][x];
                        if (feature.type === 'water') {
                            char = '≈'; cls = 'water';
                        } else if (feature.type === 'road') {
                            char = '·'; cls = 'road';
                        } else if (feature.type === 'building') {
                            char = '█'; cls = 'building';
                        } else if (feature.type === 'park') {
                            char = '♣'; cls = 'park';
                        } else if (feature.type === 'forest') {
                            char = '♠'; cls = 'forest';
                        } else {
                            char = getElevationChar(elev, centerElev);
                            cls = getElevationClass(elev, centerElev);
                        }
                    } else {
                        char = getElevationChar(elev, centerElev);
                        cls = getElevationClass(elev, centerElev);
                    }
                    
                    mapOutput += `<span class="${cls}" data-x="${x}" data-y="${y}">${char}</span>`;
                }
                mapOutput += '\n';
            }
            
            document.getElementById('map').innerHTML = mapOutput;
            document.getElementById('map').className = '';
        }

        function createOSMFeatureGrid() {
            const grid = Array(MAP_SIZE).fill().map(() => Array(MAP_SIZE).fill(null));
            const metersPerDegreeLat = 111320;
            const metersPerDegreeLon = 111320 * Math.cos(currentLat * Math.PI/180);
            
            for (const feature of osmFeatures) {
                if (feature.type === 'way') {
                    const coords = feature.nodes.map(node => ({
                        x: MAP_SIZE/2 + (node.lon - currentLon) * metersPerDegreeLon / CELL_SIZE_METERS,
                        y: MAP_SIZE/2 - (node.lat - currentLat) * metersPerDegreeLat / CELL_SIZE_METERS
                    }));
                    
                    if (feature.tags.highway) {
                        drawLineOnGrid(grid, coords, { type: 'road' });
                    } else if (feature.tags.building) {
                        drawPolygonOnGrid(grid, coords, { type: 'building' });
                    } else if (feature.tags.leisure === 'park' || feature.tags.landuse === 'grass') {
                        drawPolygonOnGrid(grid, coords, { type: 'park' });
                    } else if (feature.tags.natural === 'water') {
                        drawPolygonOnGrid(grid, coords, { type: 'water' });
                    } else if (feature.tags.natural === 'wood' || feature.tags.landuse === 'forest') {
                        drawPolygonOnGrid(grid, coords, { type: 'forest' });
                    }
                }
            }
            
            return grid;
        }

        function drawLineOnGrid(grid, coords, feature) {
            for (let i = 0; i < coords.length - 1; i++) {
                const from = coords[i];
                const to = coords[i + 1];
                drawBresenhamLine(grid, from, to, feature);
            }
        }

        function drawPolygonOnGrid(grid, coords, feature) {
            if (coords.length < 3) return;
            coords.push(coords[0]);
            
            drawLineOnGrid(grid, coords, feature);
            
            const minY = Math.max(0, Math.floor(Math.min(...coords.map(c => c.y))));
            const maxY = Math.min(MAP_SIZE-1, Math.ceil(Math.max(...coords.map(c => c.y))));
            
            for (let y = minY; y <= maxY; y++) {
                const intersections = [];
                for (let i = 0; i < coords.length - 1; i++) {
                    const from = coords[i];
                    const to = coords[i + 1];
                    
                    if ((from.y <= y && to.y > y) || (to.y <= y && from.y > y)) {
                        const x = from.x + (to.x - from.x) * (y - from.y) / (to.y - from.y);
                        intersections.push(x);
                    }
                }
                
                intersections.sort((a, b) => a - b);
                for (let i = 0; i < intersections.length; i += 2) {
                    const startX = Math.max(0, Math.floor(intersections[i]));
                    const endX = Math.min(MAP_SIZE-1, Math.ceil(intersections[i + 1] || intersections[i]));
                    
                    for (let x = startX; x <= endX; x++) {
                        if (!grid[y][x] || grid[y][x].type !== 'road') {
                            grid[y][x] = feature;
                        }
                    }
                }
            }
        }

        function drawBresenhamLine(grid, from, to, feature) {
            let x0 = Math.round(from.x);
            let y0 = Math.round(from.y);
            const x1 = Math.round(to.x);
            const y1 = Math.round(to.y);
            
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = (x0 < x1) ? 1 : -1;
            const sy = (y0 < y1) ? 1 : -1;
            let err = dx - dy;
            
            while (true) {
                if (y0 >= 0 && y0 < MAP_SIZE && x0 >= 0 && x0 < MAP_SIZE) {
                    if (!grid[y0][x0] || grid[y0][x0].type !== 'road') {
                        grid[y0][x0] = feature;
                    }
                }
                
                if (x0 === x1 && y0 === y1) break;
                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }
            }
        }

        function getElevationChar(elev, centerElev) {
            const relElev = elev - centerElev;
            if (elev < 10) return '≈';
            if (Math.abs(relElev) < 5) return '·';
            if (relElev > 20) return '█';
            if (relElev < -5) return '≈';
            return '·';
        }

        function getElevationClass(elev, centerElev) {
            const relElev = elev - centerElev;
            if (elev < 10) return 'water';
            if (Math.abs(relElev) < 5) return 'road';
            if (relElev > 20) return 'building';
            if (relElev < -5) return 'water';
            return 'ground';
        }

        // ================ INTERACTIVITY FUNCTIONS ================
        function setupMapClickHandler() {
            const mapElement = document.getElementById('map');
            const tooltip = document.getElementById('tooltip');
            
            mapElement.addEventListener('click', (e) => {
                if (!currentElevationGrid) return;
                
                let target = e.target;
                while (target && !target.hasAttribute('data-x')) {
                    target = target.parentElement;
                    if (target === mapElement) return;
                }
                
                if (target && target.hasAttribute('data-x')) {
                    const x = parseInt(target.getAttribute('data-x'));
                    const y = parseInt(target.getAttribute('data-y'));
                    const elevation = currentElevationGrid[y][x];
                    
                    if (elevation === 0) {
                        document.getElementById('elevation-info').textContent = "Clicked location is out of bounds";
                        return;
                    }
                    
                    const metersPerDegreeLat = 111320;
                    const metersPerDegreeLon = 111320 * Math.cos(currentLat * Math.PI/180);
                    const lat = currentLat + (y - MAP_SIZE/2) * (CELL_SIZE_METERS / metersPerDegreeLat);
                    const lon = currentLon + (x - MAP_SIZE/2) * (CELL_SIZE_METERS / metersPerDegreeLon);
                    
                    let featureInfo = "";
                    const osmGrid = createOSMFeatureGrid();
                    if (osmGrid[y] && osmGrid[y][x]) {
                        const feature = osmGrid[y][x];
                        if (feature.type === 'road') featureInfo = " (Road)";
                        else if (feature.type === 'building') featureInfo = " (Building)";
                        else if (feature.type === 'park') featureInfo = " (Park)";
                        else if (feature.type === 'water') featureInfo = " (Water)";
                        else if (feature.type === 'forest') featureInfo = " (Forest)";
                    }
                    
                    document.getElementById('elevation-info').textContent = 
                        `Elevation: ${elevation.toFixed(1)}m${featureInfo} | Coordinates: ${lat.toFixed(6)}, ${lon.toFixed(6)}`;
                    
                    tooltip.style.display = 'block';
                    tooltip.textContent = `${elevation.toFixed(1)}m${featureInfo}`;
                    tooltip.style.left = `${e.clientX + 10}px`;
                    tooltip.style.top = `${e.clientY + 10}px`;
                    
                    setTimeout(() => tooltip.style.display = 'none', 2000);
                }
            });
            
            mapElement.addEventListener('mousemove', (e) => {
                if (!currentElevationGrid) return;
                
                let target = e.target;
                while (target && !target.hasAttribute('data-x')) {
                    target = target.parentElement;
                    if (target === mapElement) return;
                }
                
                if (target && target.hasAttribute('data-x')) {
                    const x = parseInt(target.getAttribute('data-x'));
                    const y = parseInt(target.getAttribute('data-y'));
                    const elevation = currentElevationGrid[y][x];
                    
                    if (elevation !== 0) {
                        let featureInfo = "";
                        const osmGrid = createOSMFeatureGrid();
                        if (osmGrid[y] && osmGrid[y][x]) {
                            const feature = osmGrid[y][x];
                            if (feature.type === 'road') featureInfo = " (Road)";
                            else if (feature.type === 'building') featureInfo = " (Building)";
                            else if (feature.type === 'park') featureInfo = " (Park)";
                            else if (feature.type === 'water') featureInfo = " (Water)";
                            else if (feature.type === 'forest') featureInfo = " (Forest)";
                        }
                        
                        tooltip.style.display = 'block';
                        tooltip.textContent = `${elevation.toFixed(1)}m${featureInfo}`;
                        tooltip.style.left = `${e.clientX + 10}px`;
                        tooltip.style.top = `${e.clientY + 10}px`;
                    } else {
                        tooltip.style.display = 'none';
                    }
                } else {
                    tooltip.style.display = 'none';
                }
            });
            
            mapElement.addEventListener('mouseout', () => {
                tooltip.style.display = 'none';
            });
        }

        // ================ UTILITY FUNCTIONS ================
        function moveMap(dLat, dLon) {
            currentLat = +(currentLat + dLat).toFixed(6);
            currentLon = +(currentLon + dLon).toFixed(6);
            elevationCache.clear();
            generateMap();
        }

        function updateCoords() {
            document.getElementById('coords').textContent = 
                `Latitude: ${currentLat.toFixed(4)}, Longitude: ${currentLon.toFixed(4)}`;
        }

        async function updateLocationInfo() {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${currentLat}&lon=${currentLon}&zoom=16`);
                const data = await response.json();
                const city = data.address?.city || data.address?.town || data.address?.village || "Unknown";
                const country = data.address?.country || "Unknown";
                document.getElementById('location-info').textContent = `${city}, ${country} | Using: ${currentDataSource.name} + OSM`;
            } catch (e) {
                document.getElementById('location-info').textContent = `Using: ${currentDataSource.name} + OSM`;
            }
        }

        function updateStatus(msg) {
            document.getElementById('status').textContent = msg;
        }

        function recenter() {
            currentLat = 40.7128;
            currentLon = -74.0060;
            elevationCache.clear();
            generateMap();
        }

        function goToCoordinates() {
            const lat = parseFloat(document.getElementById('latInput').value);
            const lon = parseFloat(document.getElementById('lonInput').value);
            
            if (isNaN(lat) || isNaN(lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {
                alert("Please enter valid coordinates\nLatitude: -90 to 90\nLongitude: -180 to 180");
                return;
            }
            
            currentLat = lat;
            currentLon = lon;
            elevationCache.clear();
            generateMap();
        }

        // ================ INITIALIZATION ================
        document.getElementById('moveNorth').addEventListener('click', () => moveMap(-MOVE_DISTANCE, 0));
        document.getElementById('moveSouth').addEventListener('click', () => moveMap(MOVE_DISTANCE, 0));
        document.getElementById('moveWest').addEventListener('click', () => moveMap(0, -MOVE_DISTANCE));
        document.getElementById('moveEast').addEventListener('click', () => moveMap(0, MOVE_DISTANCE));
        document.getElementById('recenter').addEventListener('click', recenter);
        document.getElementById('goToCoords').addEventListener('click', goToCoordinates);

        setupMapClickHandler();
        generateMap();
    </script>
</body>
</html>
